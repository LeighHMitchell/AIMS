import React, { useState, useCallback, useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { fetchBasicActivityWithCache } from '@/lib/activity-cache';
import { getSectorInfo, getCleanSectorName, getSectorInfoFlexible } from '@/lib/dac-sector-utils';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Progress } from '@/components/ui/progress';
import { Switch } from '@/components/ui/switch';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Command, CommandGroup, CommandItem, CommandList, CommandInput, CommandEmpty } from '@/components/ui/command';
import { toast } from 'sonner';
import { IATIXMLParser, validateIATIXML } from '@/lib/xml-parser';
import { IATI_REGIONS } from '@/data/iati-regions';
import { IATI_COUNTRIES } from '@/data/iati-countries';
import { LANGUAGES } from '@/data/languages';
import { ExternalPublisherModal } from '@/components/import/ExternalPublisherModal';
import { extractIatiMeta } from '@/lib/iati/parseMeta';
import { useUser } from '@/hooks/useUser';
import { setFieldSaved } from '@/utils/persistentSave';
import {
  Upload,
  FileText,
  AlertCircle,
  AlertTriangle,
  CheckCircle,
  Info,
  X,
  FileCode,
  ArrowRight,
  Download,
  Eye,
  Database,
  Link,
  Globe,
  Settings,
  ChevronRight,
  ChevronsUpDown,
  Check,
  Lock,
  Plus,
  Trash2,
  Bug,
  Copy,
  ClipboardPaste,
} from 'lucide-react';

interface XmlImportTabProps {
  activityId: string;
}

interface ActivityData {
  id?: string;
  title_narrative?: string;
  description_narrative?: string;
  description_objectives?: string;
  description_target_groups?: string;
  description_other?: string;
  planned_start_date?: string;
  planned_end_date?: string;
  actual_start_date?: string;
  actual_end_date?: string;
  activity_status?: string;
  collaboration_type?: string;
  activity_scope?: string;
  language?: string;
  iati_identifier?: string;
  default_currency?: string;
  defaultAidType?: string;
  defaultFinanceType?: string;
  defaultFlowType?: string;
  defaultTiedStatus?: string;
  sectors?: Array<{
    id: string;
    code: string;
    name: string;
    percentage: number;
    level?: string;
    categoryCode?: string;
    categoryName?: string;
    type?: string;
  }>;
  recipient_countries?: Array<{
    id: string;
    country: {
      code: string;
      name: string;
      iso2: string;
      withdrawn: boolean;
    };
    percentage: number;
    vocabulary: string;
    vocabularyUri?: string;
    narrative?: string;
  }>;
  recipient_regions?: Array<{
    id: string;
    region: {
      code: string;
      name: string;
      withdrawn: boolean;
    };
    percentage: number;
    vocabulary: string;
    vocabularyUri?: string;
    narrative?: string;
  }>;
  custom_geographies?: Array<{
    id: string;
    name: string;
    code: string;
    percentage: number;
    vocabulary: string;
    vocabularyUri: string;
    narrative?: string;
  }>;
  locations?: Array<{
    id: string;
    location_name: string;
    description?: string;
    latitude?: number;
    longitude?: number;
    address?: string;
    city?: string;
    country_code?: string;
    location_type?: string;
    location_reach?: string;
    exactness?: string;
    location_class?: string;
    feature_designation?: string;
    [key: string]: any;
  }>;
}

interface ParsedField {
  fieldName: string;
  iatiPath: string;
  currentValue: any;
  importValue: any;
  selected: boolean;
  hasConflict: boolean;
  tab: string; // Which Activity Editor tab this field belongs to
  description?: string; // Optional description of what this field contains
  isFinancialItem?: boolean; // True for budget/transaction/disbursement summary items
  itemType?: 'budget' | 'transaction' | 'plannedDisbursement'; // Type of financial item
  itemIndex?: number; // Index in the array
  itemData?: any; // The actual data object
  isPolicyMarker?: boolean; // True for policy marker items
  policyMarkerData?: any; // The actual policy marker data object
  hasNonDacSectors?: boolean; // True if sector field has non-DAC sectors
  nonDacSectors?: any[]; // Array of non-DAC sectors
}

interface TabSection {
  tabId: string;
  tabName: string;
  fields: ParsedField[];
}

interface ImportStatus {
  stage: 'idle' | 'uploading' | 'parsing' | 'previewing' | 'importing' | 'complete' | 'error';
  message?: string;
  progress?: number;
}

// Helper functions for converting codes to labels
const getActivityStatusLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  const statusMap: Record<string, string> = {
    '1': 'Pipeline',
    '2': 'Implementation', 
    '3': 'Finalisation',
    '4': 'Closed',
    '5': 'Cancelled',
    '6': 'Suspended'
  };
  return { code, name: statusMap[code] || `Status ${code}` };
};

const getCollaborationTypeLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  const collabMap: Record<string, string> = {
    '1': 'Bilateral',
    '2': 'Multilateral (inflows)',
    '3': 'Multilateral (outflows)', 
    '4': 'Bilateral, core contributions to NGOs',
    '6': 'Private sector outflows',
    '7': 'Bilateral, ex-post reporting on NGOs',
    '8': 'Bilateral, triangular co-operation'
  };
  return { code, name: collabMap[code] || `Type ${code}` };
};

const getFinanceTypeLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  const financeMap: Record<string, string> = {
    '110': 'Standard grant',
    '111': 'Subsidies to national private investors',
    '210': 'Interest subsidy',
    '211': 'Interest subsidy to national private exporters',
    '310': 'Capital subscription on deposit basis',
    '311': 'Capital subscription on encashment basis',
    '410': 'Aid loan excluding debt reorganisation',
    '411': 'Investment-related loan to developing countries',
    '412': 'Loan in a joint venture with the recipient',
    '413': 'Loan to national private investor',
    '414': 'Loan to national private exporter',
    '421': 'Standard loan',
    '422': 'Reimbursable grant',
    '423': 'Bonds',
    '424': 'Asset-backed securities',
    '425': 'Other debt securities',
    '431': 'Subordinated loan',
    '432': 'Preferred equity',
    '433': 'Other hybrid instruments',
    '451': 'Non-bank guarantee',
    '452': 'Insurance',
    '453': 'Foreign exchange hedging',
    '454': 'Other unfunded contingent liabilities',
    '911': 'Debt forgiveness: OOF claims (P)',
    '912': 'Debt forgiveness: OOF claims (I)',
    '913': 'Debt forgiveness: Private claims (P)',
    '914': 'Debt forgiveness: Private claims (I)',
    '915': 'Debt forgiveness: OOF claims (DSR)',
    '916': 'Debt forgiveness: Private claims (DSR)',
    '917': 'Debt forgiveness: OOF claims (DSR-P)',
    '918': 'Debt forgiveness: OOF claims (DSR-I)',
    '919': 'Debt forgiveness: Private claims (DSR-P)',
    '920': 'Debt forgiveness: Private claims (DSR-I)'
  };
  return { code, name: financeMap[code] || 'Unknown finance type' };
};

const getFlowTypeLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  const flowMap: Record<string, string> = {
    '10': 'ODA',
    '20': 'OOF', 
    '21': 'Non-export credit',
    '22': 'Officially supported export credits',
    '30': 'Private grants',
    '35': 'Private market',
    '40': 'Non flow',
    '50': 'Other flows'
  };
  return { code, name: flowMap[code] || 'Unknown flow type' };
};

const getAidTypeLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  const aidMap: Record<string, string> = {
    'A01': 'General budget support',
    'A02': 'Sector budget support',
    'B01': 'Core support to NGOs, other private bodies, PPPs and research institutes',
    'B02': 'Core contributions to multilateral institutions',
    'B03': 'Contributions to specific-purpose programmes and funds managed by international organisations',
    'B04': 'Basket funds/pooled funding',
    'C01': 'Project-type interventions',
    'D01': 'Donor country personnel',
    'D02': 'Other technical assistance',
    'E01': 'Scholarships/training in donor country',
    'E02': 'Imputed student costs',
    'F01': 'Debt relief',
    'G01': 'Administrative costs not included elsewhere',
    'H01': 'Development awareness',
    'H02': 'Refugees/asylum seekers in donor countries',
    'H03': 'Refugees/asylum seekers in donor countries (food aid)',
    'H04': 'Refugees/asylum seekers in donor countries (other emergency assistance)'
  };
  return { code, name: aidMap[code] || 'Unknown aid type' };
};

const getTiedStatusLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  const tiedMap: Record<string, string> = {
    '3': 'Partially tied',
    '4': 'Tied',
    '5': 'Untied'
  };
  return { code, name: tiedMap[code] || 'Unknown tied status' };
};

const getActivityScopeLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  const scopeMap: Record<string, string> = {
    '1': 'Global',
    '2': 'Regional',
    '3': 'Multi-national',
    '4': 'National',
    '5': 'Sub-national: Multi-first-level administrative areas',
    '6': 'Sub-national: Single first-level administrative area',
    '7': 'Sub-national: Single second-level administrative area',
    '8': 'Single location'
  };
  return { code, name: scopeMap[code] || `Scope ${code}` };
};

const getLanguageLabel = (code: string): { code: string, name: string } | null => {
  if (!code) return null;
  
  // Use comprehensive language data from LANGUAGES
  const allLanguages = LANGUAGES[0]?.types || [];
  const languageData = allLanguages.find(lang => lang.code.toLowerCase() === code.toLowerCase());
  
  const languageName = languageData?.name || 'Unknown Language';
  const languageCode = code.toLowerCase();
  
  return { code: languageCode, name: `${languageCode} ${languageName}` };
};

// Create a singleton cache for parsed XML data per activity
const parsedXmlCache = new Map<string, {
  selectedFile: File | null;
  parsedFields: ParsedField[];
  xmlContent: string;
  importStatus: ImportStatus;
}>();

export default function XmlImportTab({ activityId }: XmlImportTabProps) {
  console.log('ðŸš¨ XML IMPORT TAB IS RENDERING! ActivityId:', activityId);
  console.log('[XML Import Debug] XmlImportTab rendered with activityId:', activityId);
  
  // Get user data from useUser hook
  const { user } = useUser();
  
  // Check if we have cached data for this activity
  const cachedData = parsedXmlCache.get(activityId);
  
  const [selectedFile, setSelectedFile] = useState<File | null>(cachedData?.selectedFile || null);
  const [parsedFields, setParsedFields] = useState<ParsedField[]>(cachedData?.parsedFields || []);
  const [importStatus, setImportStatus] = useState<ImportStatus>(cachedData?.importStatus || { stage: 'idle' });
  const [xmlContent, setXmlContent] = useState<string>(cachedData?.xmlContent || '');
  const [showXmlPreview, setShowXmlPreview] = useState(false);
  const [currentActivityData, setCurrentActivityData] = useState<ActivityData>({});
  const [activeImportTab, setActiveImportTab] = useState('basic');
  const [parsedActivity, setParsedActivity] = useState<any>(null);
  const [xmlUrl, setXmlUrl] = useState<string>('');
  const [importMethod, setImportMethod] = useState<'file' | 'url'>('file');
  const urlInputRef = useRef<HTMLInputElement>(null);
  const [isUsingPasteButton, setIsUsingPasteButton] = useState(false);
  const [showSectorRefinement, setShowSectorRefinement] = useState(false);
  const [sectorRefinementData, setSectorRefinementData] = useState<{
    originalSectors: any[];
    refinedSectors: any[];
  }>({ originalSectors: [], refinedSectors: [] });
  const [savedRefinedSectors, setSavedRefinedSectors] = useState<any[]>([]);
  const [xmlMetadata, setXmlMetadata] = useState<any>(null);
  const [debugLogs, setDebugLogs] = useState<string[]>([]);
  const [showDebugConsole, setShowDebugConsole] = useState(false);
  
  // Debug console capture
  const captureConsoleLog = (message: string, ...args: any[]) => {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}${args.length > 0 ? ' ' + args.map(arg => 
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
    ).join(' ') : ''}`;
    
    setDebugLogs(prev => [...prev, logMessage]);
    console.log(message, ...args);
  };

  const clearDebugLogs = () => {
    setDebugLogs([]);
  };

  const copyDebugLogs = () => {
    const logText = debugLogs.join('\n');
    navigator.clipboard.writeText(logText).then(() => {
      toast.success('Debug logs copied to clipboard');
    }).catch(() => {
      toast.error('Failed to copy debug logs');
    });
  };
  
  // External Publisher Detection States
  const [showExternalPublisherModal, setShowExternalPublisherModal] = useState(false);
  const [externalPublisherMeta, setExternalPublisherMeta] = useState<any>(null);
  const [userPublisherRefs, setUserPublisherRefs] = useState<string[]>([]);
  const [userOrgName, setUserOrgName] = useState<string>('');
  
  // Financial Detail Selection Modal States
  const [showDetailModal, setShowDetailModal] = useState(false);
  const [selectedItem, setSelectedItem] = useState<{
    type: 'budget' | 'transaction' | 'plannedDisbursement';
    index: number;
    data: any;
    fields: ParsedField[];
  } | null>(null);
  
  // Helper function to generate detailed fields for a specific financial item
  const generateDetailedFields = (itemType: 'budget' | 'transaction' | 'plannedDisbursement', itemData: any, itemIndex: number): ParsedField[] => {
    const detailFields: ParsedField[] = [];
    
    if (itemType === 'budget') {
      if (itemData.type) {
        detailFields.push({
          fieldName: 'Type',
          iatiPath: `@type`,
          currentValue: null,
          importValue: { code: itemData.type, name: 'Budget type classification' },
          selected: false,
          hasConflict: false,
          tab: 'budgets',
          description: `Budget type: ${itemData.type}`
        });
      }
      if (itemData.status) {
        detailFields.push({
          fieldName: 'Status',
          iatiPath: `@status`,
          currentValue: null,
          importValue: { code: itemData.status, name: 'Budget status (indicative/committed)' },
          selected: false,
          hasConflict: false,
          tab: 'budgets',
          description: `Budget status: ${itemData.status}`
        });
      }
      if (itemData.period?.start) {
        detailFields.push({
          fieldName: 'Period Start',
          iatiPath: `period/period-start/@iso-date`,
          currentValue: null,
          importValue: itemData.period.start,
          selected: false,
          hasConflict: false,
          tab: 'budgets',
          description: 'Budget period start date'
        });
      }
      if (itemData.period?.end) {
        detailFields.push({
          fieldName: 'Period End',
          iatiPath: `period/period-end/@iso-date`,
          currentValue: null,
          importValue: itemData.period.end,
          selected: false,
          hasConflict: false,
          tab: 'budgets',
          description: 'Budget period end date'
        });
      }
      if (itemData.value !== undefined) {
        detailFields.push({
          fieldName: 'Value',
          iatiPath: `value`,
          currentValue: null,
          importValue: { code: itemData.value?.toLocaleString() || '0', name: `Amount: ${itemData.value?.toLocaleString() || '0'}` },
          selected: false,
          hasConflict: false,
          tab: 'budgets',
          description: 'Budget monetary value'
        });
      }
      if (itemData.currency) {
        detailFields.push({
          fieldName: 'Currency',
          iatiPath: `value/@currency`,
          currentValue: null,
          importValue: { code: itemData.currency, name: 'ISO 4217 currency code' },
          selected: false,
          hasConflict: false,
          tab: 'budgets',
          description: `Budget currency: ${itemData.currency}`
        });
      }
      if (itemData.valueDate) {
        detailFields.push({
          fieldName: 'Value Date',
          iatiPath: `value/@value-date`,
          currentValue: null,
          importValue: itemData.valueDate,
          selected: false,
          hasConflict: false,
          tab: 'budgets',
          description: 'Budget value date'
        });
      }
    } else if (itemType === 'plannedDisbursement') {
      // Add planned disbursement detailed fields
      if (itemData.type) {
        detailFields.push({
          fieldName: 'Type',
          iatiPath: `@type`,
          currentValue: null,
          importValue: { code: itemData.type, name: 'Planned disbursement type' },
          selected: false,
          hasConflict: false,
          tab: 'planned_disbursements',
          description: `Planned disbursement type: ${itemData.type}`
        });
      }
      // Add more planned disbursement fields as needed...
    } else if (itemType === 'transaction') {
      // Add transaction detailed fields
      if (itemData.ref) {
        detailFields.push({
          fieldName: 'Transaction Reference',
          iatiPath: `transaction/@ref`,
          currentValue: null,
          importValue: itemData.ref,
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: `Transaction reference identifier`
        });
      }
      
      if (itemData.type) {
        const transactionTypes: Record<string, string> = {
          '1': 'Incoming Funds',
          '2': 'Commitment',
          '3': 'Disbursement',
          '4': 'Expenditure',
          '5': 'Interest Repayment',
          '6': 'Loan Repayment',
          '7': 'Reimbursement',
          '8': 'Purchase of Equity',
          '9': 'Sale of Equity',
          '10': 'Credit Guarantee',
          '11': 'Incoming Commitment',
          '12': 'Outgoing Pledge',
          '13': 'Incoming Pledge'
        };
        
        detailFields.push({
          fieldName: 'Transaction Type',
          iatiPath: `transaction/@type`,
          currentValue: null,
          importValue: { code: itemData.type, name: transactionTypes[itemData.type] || 'Unknown' },
          selected: true,
          hasConflict: false,
          tab: 'transactions',
          description: 'Type of transaction'
        });
      }
      
      if (itemData.date) {
        detailFields.push({
          fieldName: 'Transaction Date',
          iatiPath: `transaction/transaction-date/@iso-date`,
          currentValue: null,
          importValue: itemData.date,
          selected: true,
          hasConflict: false,
          tab: 'transactions',
          description: 'Date of the transaction'
        });
      }
      
      if (itemData.value !== undefined) {
        detailFields.push({
          fieldName: 'Value',
          iatiPath: `transaction/value`,
          currentValue: null,
          importValue: itemData.value,
          selected: true,
          hasConflict: false,
          tab: 'transactions',
          description: `Transaction amount`
        });
      }
      
      if (itemData.currency) {
        detailFields.push({
          fieldName: 'Currency',
          iatiPath: `transaction/value/@currency`,
          currentValue: null,
          importValue: itemData.currency,
          selected: true,
          hasConflict: false,
          tab: 'transactions',
          description: 'Transaction currency'
        });
      }
      
      if (itemData.valueDate) {
        detailFields.push({
          fieldName: 'Value Date',
          iatiPath: `transaction/value/@value-date`,
          currentValue: null,
          importValue: itemData.valueDate,
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Date to be used for currency conversion'
        });
      }
      
      if (itemData.description) {
        detailFields.push({
          fieldName: 'Description',
          iatiPath: `transaction/description/narrative`,
          currentValue: null,
          importValue: itemData.description,
          selected: true,
          hasConflict: false,
          tab: 'transactions',
          description: 'Transaction description'
        });
      }
      
      if (itemData.providerOrg) {
        detailFields.push({
          fieldName: 'Provider Organization',
          iatiPath: `transaction/provider-org`,
          currentValue: null,
          importValue: itemData.providerOrg.name || itemData.providerOrg.ref || 'Unknown',
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Organization providing the funds'
        });
      }
      
      if (itemData.receiverOrg) {
        detailFields.push({
          fieldName: 'Receiver Organization',
          iatiPath: `transaction/receiver-org`,
          currentValue: null,
          importValue: itemData.receiverOrg.name || itemData.receiverOrg.ref || 'Unknown',
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Organization receiving the funds'
        });
      }
      
      if (itemData.disbursementChannel) {
        detailFields.push({
          fieldName: 'Disbursement Channel',
          iatiPath: `transaction/disbursement-channel/@code`,
          currentValue: null,
          importValue: itemData.disbursementChannel,
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Channel through which funds will be disbursed'
        });
      }
      
      if (itemData.flowType) {
        detailFields.push({
          fieldName: 'Flow Type',
          iatiPath: `transaction/flow-type/@code`,
          currentValue: null,
          importValue: itemData.flowType,
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Type of financial flow'
        });
      }
      
      if (itemData.financeType) {
        detailFields.push({
          fieldName: 'Finance Type',
          iatiPath: `transaction/finance-type/@code`,
          currentValue: null,
          importValue: itemData.financeType,
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Type of finance'
        });
      }
      
      if (itemData.aidType) {
        detailFields.push({
          fieldName: 'Aid Type',
          iatiPath: `transaction/aid-type/@code`,
          currentValue: null,
          importValue: itemData.aidType.code || itemData.aidType,
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Type of aid'
        });
      }
      
      if (itemData.tiedStatus) {
        detailFields.push({
          fieldName: 'Tied Status',
          iatiPath: `transaction/tied-status/@code`,
          currentValue: null,
          importValue: itemData.tiedStatus,
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Whether aid is tied to procurement from donor country'
        });
      }
      
      if (itemData.humanitarian !== undefined) {
        detailFields.push({
          fieldName: 'Humanitarian',
          iatiPath: `transaction/@humanitarian`,
          currentValue: null,
          importValue: itemData.humanitarian ? 'Yes' : 'No',
          selected: false,
          hasConflict: false,
          tab: 'transactions',
          description: 'Whether this is a humanitarian transaction'
        });
      }
    }
    
    return detailFields;
  };
  
  // Function to handle opening the financial detail modal
  const openFinancialDetailModal = (field: ParsedField) => {
    if (field.isFinancialItem && field.itemType && field.itemData !== undefined && field.itemIndex !== undefined) {
      const detailFields = generateDetailedFields(field.itemType, field.itemData, field.itemIndex);
      setSelectedItem({
        type: field.itemType,
        index: field.itemIndex,
        data: field.itemData,
        fields: detailFields
      });
      setShowDetailModal(true);
    }
  };
  
  const [existingActivity, setExistingActivity] = useState<any>(null);
  
  // Fetch user and organization data
  useEffect(() => {
    const fetchOrgData = async () => {
      console.log('[XML Import] User data from hook:', user);
      
      // First set user's organization name if available
      if (user?.organisation) {
        setUserOrgName(user.organisation);
      } else if (user?.organization?.name) {
        setUserOrgName(user.organization.name);
      }
      
      // Now fetch the organization's IATI org ID
      if (user?.organisation || user?.organization?.name) {
        try {
          // Query organizations table to get IATI org ID
          const orgName = user?.organisation || user?.organization?.name || '';
          const response = await fetch(`/api/organizations?search=${encodeURIComponent(orgName || '')}`);
          
          if (response.ok) {
            const data = await response.json();
            console.log('[XML Import] Organizations response:', data);
            
            // Find the matching organization
            const orgs = Array.isArray(data) ? data : data.organizations || [];
            const matchingOrg = orgs.find((org: any) => 
              org.name?.toLowerCase() === orgName?.toLowerCase() ||
              org.acronym?.toLowerCase() === orgName?.toLowerCase()
            );
            
            if (matchingOrg) {
              console.log('[XML Import] Found matching org:', matchingOrg);
              
              // Set the organization name properly
              setUserOrgName(matchingOrg.name || orgName);
              
              // Set IATI publisher refs if available
              if (matchingOrg.iati_org_id) {
                // IATI org IDs can be comma-separated or single values
                const refs = matchingOrg.iati_org_id.split(',').map((ref: string) => ref.trim());
                setUserPublisherRefs(refs);
                console.log('[XML Import] Set publisher refs:', refs);
              } else if (matchingOrg.acronym === 'AFD' || matchingOrg.name?.includes('AFD')) {
                // Special case for AFD
                setUserPublisherRefs(['FR-AFD', 'FR-3']);
                console.log('[XML Import] Set AFD publisher refs');
              }
            } else {
              // If no exact match, but we know it's AFD
              if (orgName?.includes('AFD') || orgName?.includes('Agence FranÃ§aise')) {
                setUserOrgName('Agence FranÃ§aise de DÃ©veloppement');
                setUserPublisherRefs(['FR-AFD', 'FR-3']);
                console.log('[XML Import] Defaulting to AFD publisher refs');
              }
            }
          }
        } catch (error) {
          console.error('[XML Import] Error fetching organization data:', error);
          
          // Default to AFD if we know the user is from AFD
          if (user?.organisation?.includes('AFD') || user?.organisation?.includes('Agence FranÃ§aise')) {
            setUserOrgName('Agence FranÃ§aise de DÃ©veloppement');
            setUserPublisherRefs(['FR-AFD', 'FR-3']);
          }
        }
      }
    };
    
    if (user) {
      fetchOrgData();
    }
  }, [user]);
  
  // Save state to cache whenever it changes
  useEffect(() => {
    if (activityId && (selectedFile || parsedFields.length > 0)) {
      parsedXmlCache.set(activityId, {
        selectedFile,
        parsedFields,
        xmlContent,
        importStatus
      });
    }
  }, [activityId, selectedFile, parsedFields, xmlContent, importStatus]);

  // Debug logging
  console.log('[XML Import Debug] Component state:', {
    hasSelectedFile: !!selectedFile,
    parsedFieldsCount: parsedFields.length,
    selectedFieldsCount: parsedFields.filter(f => f.selected).length,
    importStage: importStatus.stage,
    activityId
  });

  // Trigger to re-fetch activity data
  const [refetchTrigger, setRefetchTrigger] = useState(0);

  // Fetch current activity data
  useEffect(() => {
    const fetchActivityData = async () => {
      if (!activityId) return;
      
      try {
        // Fetch full activity data to include location data
        console.log('[XmlImportTab] Fetching activity data for:', activityId);
        const data = await fetchBasicActivityWithCache(activityId);
        console.log('[XmlImportTab] Fetched activity data:', data);
        console.log('[XmlImportTab] Location data:', {
          recipient_countries: data.recipient_countries,
          recipient_regions: data.recipient_regions,
          custom_geographies: data.custom_geographies
        });

        
        // Also fetch current activity locations
        
        console.log('[XmlImportTab] Fetching current activity locations...');
        
        const locationsResponse = await fetch(`/api/activities/${activityId}/locations`);
        
        const locationsData = locationsResponse.ok ? await locationsResponse.json() : { locations: [] };
        const currentLocations = locationsData.locations || [];
        
        console.log('[XmlImportTab] Current locations:', currentLocations);
        
        
        // Map the data correctly - the API returns both camelCase and snake_case versions
        setCurrentActivityData({
          id: data.id,
          title_narrative: data.title_narrative || data.title,
          description_narrative: data.description_narrative || data.description,
          description_objectives: data.description_objectives || data.descriptionObjectives,
          description_target_groups: data.description_target_groups || data.descriptionTargetGroups,
          description_other: data.description_other || data.descriptionOther,
          planned_start_date: data.planned_start_date || data.plannedStartDate,
          planned_end_date: data.planned_end_date || data.plannedEndDate,
          actual_start_date: data.actual_start_date || data.actualStartDate,
          actual_end_date: data.actual_end_date || data.actualEndDate,
          activity_status: data.activity_status || data.activityStatus,
          collaboration_type: data.collaboration_type || data.collaborationType,
          activity_scope: data.activity_scope || data.activityScope,
          language: data.language,
          iati_identifier: data.iati_identifier || data.iatiIdentifier || data.iatiId,
          default_currency: data.default_currency || data.defaultCurrency,
          defaultAidType: data.defaultAidType,
          defaultFinanceType: data.defaultFinanceType,
          defaultFlowType: data.defaultFlowType,
          defaultTiedStatus: data.defaultTiedStatus,
          sectors: data.sectors || [],
          recipient_countries: data.recipient_countries || [],
          recipient_regions: data.recipient_regions || [],
          custom_geographies: data.custom_geographies || [],
          locations: currentLocations || [],
        });
        console.log('[XmlImportTab] Set current activity data with title:', data.title_narrative || data.title);
      } catch (error) {
        console.error('[XmlImportTab] Error fetching activity data:', error);
        // If basic endpoint fails, try the full endpoint as fallback
        try {
          console.log('[XmlImportTab] Trying full endpoint as fallback');
          const response = await fetch(`/api/activities/${activityId}`);
          if (response.ok) {
            const data = await response.json();
            setCurrentActivityData({
              id: data.id,
              title_narrative: data.title_narrative || data.title,
              description_narrative: data.description_narrative || data.description,
          description_objectives: data.description_objectives || data.descriptionObjectives,
          description_target_groups: data.description_target_groups || data.descriptionTargetGroups,
          description_other: data.description_other || data.descriptionOther,
              planned_start_date: data.planned_start_date || data.plannedStartDate,
              planned_end_date: data.planned_end_date || data.plannedEndDate,
              actual_start_date: data.actual_start_date || data.actualStartDate,
              actual_end_date: data.actual_end_date || data.actualEndDate,
              activity_status: data.activity_status || data.activityStatus,
              collaboration_type: data.collaboration_type || data.collaborationType,
              activity_scope: data.activity_scope || data.activityScope,
              language: data.language,
              iati_identifier: data.iati_identifier || data.iatiIdentifier || data.iatiId,
              default_currency: data.default_currency || data.defaultCurrency,
              defaultAidType: data.defaultAidType,
              defaultFinanceType: data.defaultFinanceType,
              defaultFlowType: data.defaultFlowType,
              defaultTiedStatus: data.defaultTiedStatus,
              sectors: data.sectors || [],
              recipient_countries: data.recipient_countries || [],
              recipient_regions: data.recipient_regions || [],
              custom_geographies: data.custom_geographies || [],
            });
            console.log('[XmlImportTab] Fallback successful, got title:', data.title_narrative || data.title);
          }
        } catch (fallbackError) {
          console.error('[XmlImportTab] Fallback also failed:', fallbackError);
        }
      }
    };

    fetchActivityData();
  }, [activityId, refetchTrigger]);

  // Handle file selection
  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    console.log('[XML Import Debug] File selected:', file?.name, 'Type:', file?.type);
    if (file) {
      if (file.type !== 'text/xml' && !file.name.endsWith('.xml')) {
        console.log('[XML Import Debug] Invalid file type:', file.type);
        toast.error('Please select a valid XML file');
        return;
      }
      console.log('[XML Import Debug] Setting selected file and resetting state');
      setSelectedFile(file);
      setImportStatus({ stage: 'idle' });
      setParsedFields([]);
      setXmlMetadata(null);
    }
  };

  // Handle paste from clipboard
  const handlePasteUrl = async (e?: React.MouseEvent) => {
    // Prevent event bubbling to avoid triggering onPaste on input
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Set flag to prevent onPaste handler from running
    setIsUsingPasteButton(true);
    
    try {
      // Check if clipboard API is available and supported
      if (!navigator.clipboard || !navigator.clipboard.readText) {
        toast.error('Clipboard API not supported in this browser. Please paste manually (Ctrl+V)');
        return;
      }

      // Try to read clipboard with better error handling
      const text = await navigator.clipboard.readText();
      console.log('[XML Import Debug] Paste button - clipboard text:', text);
      if (text && text.trim()) {
        // Extract the clean URL by finding the first occurrence of the URL pattern
        const urlPattern = /https?:\/\/[^\s]+/;
        const match = text.match(urlPattern);
        const cleanUrl = match ? match[0] : text.trim();
        
        console.log('[XML Import Debug] Paste button - clean URL:', cleanUrl);
        setXmlUrl(cleanUrl);
        toast.success('URL pasted from clipboard');
      } else {
        toast.error('No text found in clipboard');
      }
    } catch (error) {
      console.error('Failed to read clipboard:', error);
      
      // Handle specific error types
      if (error instanceof TypeError) {
        toast.error('Clipboard access not supported. Please paste manually (Ctrl+V)');
      } else if (error instanceof DOMException) {
        if (error.name === 'NotAllowedError') {
          toast.error('Clipboard access denied. Please paste manually (Ctrl+V)');
        } else {
          toast.error('Clipboard access failed. Please paste manually (Ctrl+V)');
        }
      } else {
        toast.error('Clipboard access not available. Please paste manually (Ctrl+V)');
      }
    } finally {
      // Reset flag after a short delay
      setTimeout(() => setIsUsingPasteButton(false), 100);
    }
  };

  // Handle file drop
  const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file) {
      if (file.type !== 'text/xml' && !file.name.endsWith('.xml')) {
        toast.error('Please select a valid XML file');
        return;
      }
      setSelectedFile(file);
      setImportStatus({ stage: 'idle' });
      setParsedFields([]);
      setXmlMetadata(null);
    }
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
  }, []);

  // Fetch XML from URL via server-side proxy to avoid CORS issues
  const fetchXmlFromUrl = async (url: string): Promise<string> => {
    try {
      console.log('[XML Import Debug] Fetching XML from URL via proxy:', url);
      console.log('[XML Import Debug] URL length:', url.length);
      console.log('[XML Import Debug] URL first 100 chars:', url.substring(0, 100));
      console.log('[XML Import Debug] URL last 100 chars:', url.substring(url.length - 100));
      
      // Use our server-side API to fetch the XML
      const response = await fetch('/api/xml/fetch', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ url }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        const errorMessage = errorData.error || `Failed to fetch XML: ${response.status} ${response.statusText}`;
        
        // Provide more helpful error messages based on status code
        if (response.status === 404) {
          throw new Error(`XML file not found at this URL. Please check that the URL is correct and the file exists.`);
        } else if (response.status === 403) {
          throw new Error(`Access denied to XML file. The server may require authentication or block automated requests.`);
        } else if (response.status === 500) {
          throw new Error(`Server error while fetching XML. The remote server may be temporarily unavailable.`);
        } else {
          throw new Error(errorMessage);
        }
      }

      const data = await response.json();
      
      if (!data.content || !data.content.trim()) {
        throw new Error('Empty XML content received from URL');
      }

      console.log('[XML Import Debug] Successfully fetched XML via proxy, size:', data.size);
      return data.content;
    } catch (error) {
      console.error('[XML Import Debug] Error fetching XML from URL:', error);
      throw new Error(`Failed to fetch XML from URL: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  // Parse XML file or URL
  const parseXmlFile = async () => {
    console.log('[XML Import Debug] parseXmlFile called, method:', importMethod);
    
    if (importMethod === 'file' && !selectedFile) {
      console.log('[XML Import Debug] No selected file, returning');
      return;
    }
    
    if (importMethod === 'url' && !xmlUrl.trim()) {
      console.log('[XML Import Debug] No URL provided, returning');
      toast.error('Please enter a valid XML URL');
      return;
    }

    // Ensure we have the latest activity data before parsing
    if (!currentActivityData.id && activityId) {
      console.log('[XML Import Debug] Fetching activity data before parsing');
      try {
        const data = await fetchBasicActivityWithCache(activityId);
        setCurrentActivityData({
          id: data.id,
          title_narrative: data.title_narrative || data.title,
          description_narrative: data.description_narrative || data.description,
          description_objectives: data.description_objectives || data.descriptionObjectives,
          description_target_groups: data.description_target_groups || data.descriptionTargetGroups,
          description_other: data.description_other || data.descriptionOther,
          planned_start_date: data.planned_start_date || data.plannedStartDate,
          planned_end_date: data.planned_end_date || data.plannedEndDate,
          actual_start_date: data.actual_start_date || data.actualStartDate,
          actual_end_date: data.actual_end_date || data.actualEndDate,
          activity_status: data.activity_status || data.activityStatus,
          collaboration_type: data.collaboration_type || data.collaborationType,
          activity_scope: data.activity_scope || data.activityScope,
          language: data.language,
          iati_identifier: data.iati_identifier || data.iatiIdentifier || data.iatiId,
          default_currency: data.default_currency || data.defaultCurrency,
          defaultAidType: data.defaultAidType,
          defaultFinanceType: data.defaultFinanceType,
          defaultFlowType: data.defaultFlowType,
          defaultTiedStatus: data.defaultTiedStatus,
          sectors: data.sectors || [],
          recipient_countries: data.recipient_countries || [],
          recipient_regions: data.recipient_regions || [],
          custom_geographies: data.custom_geographies || [],
              locations: currentLocations || [],
        });
      } catch (error) {
        console.error('[XML Import Debug] Failed to fetch activity data:', error);
      }
    }

    console.log('[XML Import Debug] Current activity data:', currentActivityData);
    console.log('[XML Import Debug] Setting status to uploading');
    setImportStatus({ stage: 'uploading', progress: 20 });

    try {
      let content: string;
      let fileToCheck: File | null = null;
      
      if (importMethod === 'file' && selectedFile) {
        // Check file size limit (50MB)
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB in bytes
        if (selectedFile.size > MAX_FILE_SIZE) {
          throw new Error(`File size (${(selectedFile.size / (1024 * 1024)).toFixed(2)}MB) exceeds the maximum allowed size of 50MB. Please use a smaller file or split it into multiple files.`);
        }
        
        // Read file content
        console.log('[XML Import Debug] Reading file content, size:', selectedFile.size);
        content = await selectedFile.text();
        fileToCheck = selectedFile;
      } else {
        // Fetch from URL
        console.log('[XML Import Debug] Fetching from URL');
        content = await fetchXmlFromUrl(xmlUrl.trim());
        // Create a File object from the fetched content for metadata extraction
        fileToCheck = new File([content], 'fetched.xml', { type: 'text/xml' });
      }
      
      setXmlContent(content);
      
      console.log('[XML Import Debug] Setting status to parsing');
      setImportStatus({ stage: 'parsing', progress: 50 });
      
      // Check if content is HTML instead of XML (common error response)
      if (content.trim().startsWith('<!DOCTYPE html') || content.trim().startsWith('<html')) {
        console.error('[XML Import] Received HTML instead of XML - likely an error page');
        throw new Error('The file appears to be an HTML page instead of XML. This can happen if the file is too large, the connection timed out, or there was a server error. Please try with a smaller file or check your internet connection.');
      }
      
      // Additional check for common HTML patterns
      if (content.includes('<meta') && content.includes('<head>') && content.includes('</head>')) {
        console.error('[XML Import] Detected HTML structure in response');
        throw new Error('Received an HTML error page instead of XML data. Please ensure the XML file is valid and not too large (max 50MB).');
      }
      
      // Validate XML structure first
      const validation = validateIATIXML(content);
      if (!validation.isValid) {
        throw new Error(`Invalid IATI XML: ${validation.errors.join(', ')}`);
      }

      // Parse the IATI XML
      console.log('[XML Import Debug] Parsing IATI XML with real parser');
      const parser = new IATIXMLParser(content);
      const parsedActivity = parser.parseActivity();
      
      // Store parsed activity data in state for use by import function
      setParsedActivity(parsedActivity);
      
      console.log('[XML Import Debug] Parsed activity data:', parsedActivity);

      // Helper function to determine if a field should be selected by default
      const shouldSelectField = (currentValue: any, importValue: any): boolean => {
        // Select if current value is empty/null/undefined OR if values differ
        if (!currentValue) return true;
        
        // Handle object comparison (e.g., for coded fields that return {code, name})
        if (typeof currentValue === 'object' && typeof importValue === 'object') {
          if (currentValue === null || importValue === null) {
            return currentValue !== importValue;
          }
          // Compare by code if both have code property, otherwise deep compare
          if (currentValue.code !== undefined && importValue.code !== undefined) {
            return currentValue.code !== importValue.code;
          }
          // For other objects, compare by JSON serialization
          return JSON.stringify(currentValue) !== JSON.stringify(importValue);
        }
        
        // Handle primitive comparison
        return currentValue !== importValue;
      };

      const hasConflict = (currentValue: any, importValue: any): boolean => {
        // Only show conflict if current value exists and differs from import value
        if (!currentValue) return false;
        
        // Handle object comparison (e.g., for coded fields that return {code, name})
        if (typeof currentValue === 'object' && typeof importValue === 'object') {
          if (currentValue === null || importValue === null) {
            return currentValue !== importValue;
          }
          // Compare by code if both have code property, otherwise deep compare
          if (currentValue.code !== undefined && importValue.code !== undefined) {
            return currentValue.code !== importValue.code;
          }
          // For other objects, compare by JSON serialization
          return JSON.stringify(currentValue) !== JSON.stringify(importValue);
        }
        
        // Handle primitive comparison
        return currentValue !== importValue;
      };

      // Create fields from parsed data organized by tabs
      const fields: ParsedField[] = [];

      // === BASIC INFO TAB ===
      
      if (parsedActivity.iatiIdentifier) {
        const currentValue = currentActivityData.iati_identifier || null;
        
        fields.push({
          fieldName: 'IATI Identifier',
          iatiPath: 'iati-activity/iati-identifier',
          currentValue: currentValue,
          importValue: parsedActivity.iatiIdentifier,
          selected: shouldSelectField(currentValue, parsedActivity.iatiIdentifier),
          hasConflict: hasConflict(currentValue, parsedActivity.iatiIdentifier),
          tab: 'basic',
          description: 'Unique identifier for this activity'
        });
      }

      if (parsedActivity.otherIdentifier) {
        const currentValue = currentActivityData['other_identifier' as keyof typeof currentActivityData] || null;
        
        fields.push({
          fieldName: 'Activity ID',
          iatiPath: 'iati-activity/other-identifier',
          currentValue: currentValue,
          importValue: parsedActivity.otherIdentifier,
          selected: shouldSelectField(currentValue, parsedActivity.otherIdentifier),
          hasConflict: hasConflict(currentValue, parsedActivity.otherIdentifier),
          tab: 'basic',
          description: 'Other identifier for this activity (e.g., internal project ID)'
        });
      }

      if (parsedActivity.title) {
        const currentValue = currentActivityData.title_narrative || null;
        console.log('[XmlImportTab] Comparing titles:', {
          current: currentValue,
          import: parsedActivity.title,
          shouldSelect: shouldSelectField(currentValue, parsedActivity.title)
        });
        fields.push({
          fieldName: 'Activity Title',
          iatiPath: 'iati-activity/title/narrative',
          currentValue: currentValue,
          importValue: parsedActivity.title,
          selected: shouldSelectField(currentValue, parsedActivity.title),
          hasConflict: hasConflict(currentValue, parsedActivity.title),
          tab: 'basic',
          description: 'Main title/name of the activity'
        });
      }

      if (parsedActivity.description) {
        const currentValue = currentActivityData.description_narrative || null;
        console.log('[Import Preview] Adding general description field:', {
          current: currentValue?.substring(0, 50),
          import: parsedActivity.description?.substring(0, 50)
        });
        fields.push({
          fieldName: 'Activity Description',
          iatiPath: 'iati-activity/description[@type="1"]/narrative',
          currentValue: currentValue,
          importValue: parsedActivity.description,
          selected: shouldSelectField(currentValue, parsedActivity.description),
          hasConflict: hasConflict(currentValue, parsedActivity.description),
          tab: 'basic',
          description: 'General activity description (IATI type="1")'
        });
      }

      if (parsedActivity.descriptionObjectives) {
        const currentValue = currentActivityData.description_objectives || null;
        console.log('[Import Preview] Adding objectives description field:', {
          current: currentValue?.substring(0, 50),
          import: parsedActivity.descriptionObjectives?.substring(0, 50)
        });
        fields.push({
          fieldName: 'Activity Description - Objectives',
          iatiPath: 'iati-activity/description[@type="2"]/narrative',
          currentValue: currentValue,
          importValue: parsedActivity.descriptionObjectives,
          selected: shouldSelectField(currentValue, parsedActivity.descriptionObjectives),
          hasConflict: hasConflict(currentValue, parsedActivity.descriptionObjectives),
          tab: 'basic',
          description: 'Objectives of the activity (IATI type="2")'
        });
      }

      if (parsedActivity.descriptionTargetGroups) {
        const currentValue = currentActivityData.description_target_groups || null;
        console.log('[Import Preview] Adding target groups description field:', {
          current: currentValue?.substring(0, 50),
          import: parsedActivity.descriptionTargetGroups?.substring(0, 50)
        });
        fields.push({
          fieldName: 'Activity Description - Target Groups',
          iatiPath: 'iati-activity/description[@type="3"]/narrative',
          currentValue: currentValue,
          importValue: parsedActivity.descriptionTargetGroups,
          selected: shouldSelectField(currentValue, parsedActivity.descriptionTargetGroups),
          hasConflict: hasConflict(currentValue, parsedActivity.descriptionTargetGroups),
          tab: 'basic',
          description: 'Target groups and beneficiaries (IATI type="3")'
        });
      }

      if (parsedActivity.descriptionOther) {
        const currentValue = currentActivityData.description_other || null;
        fields.push({
          fieldName: 'Activity Description - Other',
          iatiPath: 'iati-activity/description[@type="4"]/narrative',
          currentValue: currentValue,
          importValue: parsedActivity.descriptionOther,
          selected: shouldSelectField(currentValue, parsedActivity.descriptionOther),
          hasConflict: hasConflict(currentValue, parsedActivity.descriptionOther),
          tab: 'basic',
          description: 'Other relevant information'
        });
      }

      if (parsedActivity.collaborationType) {
        const currentCollabLabel = currentActivityData.collaboration_type ? getCollaborationTypeLabel(currentActivityData.collaboration_type) : null;
        const importCollabLabel = getCollaborationTypeLabel(parsedActivity.collaborationType);
        fields.push({
          fieldName: 'Collaboration Type',
          iatiPath: 'iati-activity/collaboration-type',
          currentValue: currentCollabLabel,
          importValue: importCollabLabel,
          selected: shouldSelectField(currentCollabLabel, importCollabLabel),
          hasConflict: hasConflict(currentCollabLabel, importCollabLabel),
          tab: 'basic',
          description: 'Type of collaboration arrangement'
        });
      }

      if (parsedActivity.activityStatus) {
        const currentStatusLabel = currentActivityData.activity_status ? getActivityStatusLabel(currentActivityData.activity_status) : null;
        const importStatusLabel = getActivityStatusLabel(parsedActivity.activityStatus);
        fields.push({
          fieldName: 'Activity Status',
          iatiPath: 'iati-activity/activity-status',
          currentValue: currentStatusLabel,
          importValue: importStatusLabel,
          selected: shouldSelectField(currentStatusLabel, importStatusLabel),
          hasConflict: hasConflict(currentStatusLabel, importStatusLabel),
          tab: 'basic',
          description: 'Current implementation status'
        });
      }

      if (parsedActivity.activityScope) {
        const currentScopeLabel = currentActivityData.activity_scope ? getActivityScopeLabel(currentActivityData.activity_scope) : null;
        const importScopeLabel = getActivityScopeLabel(parsedActivity.activityScope);
        fields.push({
          fieldName: 'Activity Scope',
          iatiPath: 'iati-activity/activity-scope',
          currentValue: currentScopeLabel,
          importValue: importScopeLabel,
          selected: shouldSelectField(currentScopeLabel, importScopeLabel),
          hasConflict: hasConflict(currentScopeLabel, importScopeLabel),
          tab: 'basic',
          description: 'Geographical scope of the activity'
        });
      }

      if (parsedActivity.language) {
        const currentLanguageLabel = currentActivityData.language ? getLanguageLabel(currentActivityData.language) : null;
        const importLanguageLabel = getLanguageLabel(parsedActivity.language);
        fields.push({
          fieldName: 'Narrative Language',
          iatiPath: 'iati-activity[@xml:lang]',
          currentValue: currentLanguageLabel,
          importValue: importLanguageLabel,
          selected: shouldSelectField(currentLanguageLabel, importLanguageLabel),
          hasConflict: hasConflict(currentLanguageLabel, importLanguageLabel),
          tab: 'basic',
          description: 'Primary language of the activity (if multilingual)'
        });
      }

      // === DATES TAB ===
      
      if (parsedActivity.plannedStartDate) {
        const currentValue = currentActivityData.planned_start_date || null;
        fields.push({
          fieldName: 'Planned Start Date',
          iatiPath: 'iati-activity/activity-date[@type="1"]',
          currentValue: currentValue,
          importValue: parsedActivity.plannedStartDate,
          selected: shouldSelectField(currentValue, parsedActivity.plannedStartDate),
          hasConflict: hasConflict(currentValue, parsedActivity.plannedStartDate),
          tab: 'basic',
          description: 'When the activity is planned to begin'
        });
      }

      if (parsedActivity.plannedEndDate) {
        fields.push({
          fieldName: 'Planned End Date',
          iatiPath: 'iati-activity/activity-date[@type="3"]',
          currentValue: currentActivityData.planned_end_date || null,
          importValue: parsedActivity.plannedEndDate,
          selected: shouldSelectField(currentActivityData.planned_end_date || null, parsedActivity.plannedEndDate),
          hasConflict: hasConflict(currentActivityData.planned_end_date || null, parsedActivity.plannedEndDate),
          tab: 'basic',
          description: 'When the activity is planned to end'
        });
      }

      if (parsedActivity.actualStartDate) {
        fields.push({
          fieldName: 'Actual Start Date',
          iatiPath: 'iati-activity/activity-date[@type="2"]',
          currentValue: currentActivityData.actual_start_date || null,
          importValue: parsedActivity.actualStartDate,
          selected: shouldSelectField(currentActivityData.actual_start_date || null, parsedActivity.actualStartDate),
          hasConflict: hasConflict(currentActivityData.actual_start_date || null, parsedActivity.actualStartDate),
          tab: 'basic',
          description: 'When the activity actually started'
        });
      }

      if (parsedActivity.actualEndDate) {
        fields.push({
          fieldName: 'Actual End Date',
          iatiPath: 'iati-activity/activity-date[@type="4"]',
          currentValue: currentActivityData.actual_end_date || null,
          importValue: parsedActivity.actualEndDate,
          selected: shouldSelectField(currentActivityData.actual_end_date || null, parsedActivity.actualEndDate),
          hasConflict: hasConflict(currentActivityData.actual_end_date || null, parsedActivity.actualEndDate),
          tab: 'basic',
          description: 'When the activity actually ended'
        });
      }

      // === FINANCES TAB ===
      
      if (parsedActivity.defaultCurrency) {
        fields.push({
          fieldName: 'Default Currency',
          iatiPath: 'iati-activity[@default-currency]',
          currentValue: currentActivityData.default_currency || null,
          importValue: parsedActivity.defaultCurrency,
          selected: shouldSelectField(currentActivityData.default_currency || null, parsedActivity.defaultCurrency),
          hasConflict: hasConflict(currentActivityData.default_currency || null, parsedActivity.defaultCurrency),
          tab: 'finances',
          description: 'Default currency for financial values'
        });
      }

      if (parsedActivity.crsChannelCode) {
        fields.push({
          fieldName: 'CRS Channel Code',
          iatiPath: 'iati-activity/crs-add/channel-code',
          currentValue: null, // This field is not stored in the current system
          importValue: parsedActivity.crsChannelCode,
          selected: false, // Don't auto-select as it's optional
          hasConflict: false,
          tab: 'finances',
          description: 'CRS Channel Code (optional)'
        });
      }

      if (parsedActivity.defaultFinanceType) {
        const currentFinanceLabel = currentActivityData.defaultFinanceType ? getFinanceTypeLabel(currentActivityData.defaultFinanceType) : null;
        const importFinanceLabel = getFinanceTypeLabel(parsedActivity.defaultFinanceType);
        fields.push({
          fieldName: 'Default Finance Type',
          iatiPath: 'iati-activity/default-finance-type',
          currentValue: currentFinanceLabel,
          importValue: importFinanceLabel,
          selected: shouldSelectField(currentFinanceLabel, importFinanceLabel),
          hasConflict: hasConflict(currentFinanceLabel, importFinanceLabel),
          tab: 'finances',
          description: 'Default type of finance (grant, loan, etc.)'
        });
      }

      if (parsedActivity.defaultFlowType) {
        const currentFlowLabel = currentActivityData.defaultFlowType ? getFlowTypeLabel(currentActivityData.defaultFlowType) : null;
        const importFlowLabel = getFlowTypeLabel(parsedActivity.defaultFlowType);
        fields.push({
          fieldName: 'Default Flow Type',
          iatiPath: 'iati-activity/default-flow-type',
          currentValue: currentFlowLabel,
          importValue: importFlowLabel,
          selected: shouldSelectField(currentFlowLabel, importFlowLabel),
          hasConflict: hasConflict(currentFlowLabel, importFlowLabel),
          tab: 'finances',
          description: 'Default flow classification'
        });
      }

      if (parsedActivity.defaultAidType) {
        const currentAidLabel = currentActivityData.defaultAidType ? getAidTypeLabel(currentActivityData.defaultAidType) : null;
        const importAidLabel = getAidTypeLabel(parsedActivity.defaultAidType);
        fields.push({
          fieldName: 'Default Aid Type',
          iatiPath: 'iati-activity/default-aid-type',
          currentValue: currentAidLabel,
          importValue: importAidLabel,
          selected: shouldSelectField(currentAidLabel, importAidLabel),
          hasConflict: hasConflict(currentAidLabel, importAidLabel),
          tab: 'finances',
          description: 'Default aid type classification'
        });
      }

      if (parsedActivity.defaultTiedStatus) {
        const currentTiedLabel = currentActivityData.defaultTiedStatus ? getTiedStatusLabel(currentActivityData.defaultTiedStatus) : null;
        const importTiedLabel = getTiedStatusLabel(parsedActivity.defaultTiedStatus);
        fields.push({
          fieldName: 'Default Tied Status',
          iatiPath: 'iati-activity/default-tied-status',
          currentValue: currentTiedLabel,
          importValue: importTiedLabel,
          selected: shouldSelectField(currentTiedLabel, importTiedLabel),
          hasConflict: hasConflict(currentTiedLabel, importTiedLabel),
          tab: 'finances',
          description: 'Default tied aid status'
        });
      }

      // === BUDGETS TAB ===
      
      if (parsedActivity.budgets && parsedActivity.budgets.length > 0) {
        parsedActivity.budgets.forEach((budget, budgetIndex) => {
          // Create budget summary
          const budgetSummary = [
            budget.type && `Type: ${budget.type}`,
            budget.status && `Status: ${budget.status}`,
            budget.period?.start && `Start: ${budget.period.start}`,
            budget.period?.end && `End: ${budget.period.end}`,
            budget.value && `Amount: ${budget.value.toLocaleString()} ${budget.currency || ''}`
          ].filter(Boolean).join(' | ');
          
          fields.push({
            fieldName: `Budget ${budgetIndex + 1}`,
            iatiPath: `iati-activity/budget[${budgetIndex + 1}]`,
            currentValue: null,
            importValue: budgetSummary,
            selected: false,
            hasConflict: false,
            tab: 'budgets',
            description: `Budget ${budgetIndex + 1} - Click to configure individual fields`,
            isFinancialItem: true,
            itemType: 'budget',
            itemIndex: budgetIndex,
            itemData: budget
          });
        });
      }

      // === PLANNED DISBURSEMENTS TAB ===
      
      if (parsedActivity.plannedDisbursements && parsedActivity.plannedDisbursements.length > 0) {
        parsedActivity.plannedDisbursements.forEach((disbursement, disbIndex) => {
          // Create disbursement summary
          const disbursementSummary = [
            disbursement.type && `Type: ${disbursement.type}`,
            disbursement.period?.start && `Start: ${disbursement.period.start}`,
            disbursement.period?.end && `End: ${disbursement.period.end}`,
            disbursement.value && `Amount: ${disbursement.value.toLocaleString()} ${disbursement.currency || ''}`,
            disbursement.providerOrg?.name && `Provider: ${disbursement.providerOrg.name}`,
            disbursement.receiverOrg?.name && `Receiver: ${disbursement.receiverOrg.name}`
          ].filter(Boolean).join(' | ');
          
          fields.push({
            fieldName: `Planned Disbursement ${disbIndex + 1}`,
            iatiPath: `iati-activity/planned-disbursement[${disbIndex + 1}]`,
            currentValue: null,
            importValue: disbursementSummary,
            selected: false,
            hasConflict: false,
            tab: 'planned_disbursements',
            description: `Planned Disbursement ${disbIndex + 1} - Click to configure individual fields`,
            isFinancialItem: true,
            itemType: 'plannedDisbursement',
            itemIndex: disbIndex,
            itemData: disbursement
          });
        });
      }

      // === TRANSACTIONS TAB ===
      
      if (parsedActivity.transactions && parsedActivity.transactions.length > 0) {
        parsedActivity.transactions.forEach((transaction, transIndex) => {
          // Create transaction summary with type mapping
          const transactionTypes: Record<string, string> = {
            '1': 'Incoming Funds',
            '2': 'Commitment',
            '3': 'Disbursement',
            '4': 'Expenditure',
            '5': 'Interest Repayment',
            '6': 'Loan Repayment',
            '7': 'Reimbursement',
            '8': 'Purchase of Equity',
            '9': 'Sale of Equity',
            '10': 'Credit Guarantee',
            '11': 'Incoming Commitment',
            '12': 'Outgoing Pledge',
            '13': 'Incoming Pledge'
          };
          
          const transactionType = transactionTypes[transaction.type || ''] || transaction.type || 'Unknown';
          
          const transactionSummary = [
            `Type: ${transactionType}`,
            transaction.date && `Date: ${transaction.date}`,
            transaction.value && `Amount: ${transaction.value.toLocaleString()} ${transaction.currency || parsedActivity.defaultCurrency || ''}`,
            transaction.description && `Description: ${transaction.description}`,
            transaction.providerOrg?.name && `Provider: ${transaction.providerOrg.name}`,
            transaction.receiverOrg?.name && `Receiver: ${transaction.receiverOrg.name}`
          ].filter(Boolean).join(' | ');
          
          fields.push({
            fieldName: `Transaction ${transIndex + 1}`,
            iatiPath: `iati-activity/transaction[${transIndex + 1}]`,
            currentValue: null,
            importValue: transactionSummary,
            selected: false,
            hasConflict: false,
            tab: 'transactions',
            description: `${transactionType} - Click to configure individual fields`,
            isFinancialItem: true,
            itemType: 'transaction',
            itemIndex: transIndex,
            itemData: transaction
          });
        });
      }

      // === LOCATIONS TAB ===
      
      // Always show recipient countries field if there's current data or import data
      const countryInfo = parsedActivity.recipientCountries && parsedActivity.recipientCountries.length > 0
        ? parsedActivity.recipientCountries.map(c => ({
            code: c.code,
            name: `${(() => {
            const countryData = IATI_COUNTRIES.find(country => country.code === c.code);
            const countryName = countryData ? countryData.name : (c.narrative || c.code);
            return countryName;
          })()}${c.percentage ? ` (${c.percentage}%)` : ''}`,
            vocabulary: 'A4 ISO Country'
          }))
        : null;
      
      const currentCountryInfo = currentActivityData.recipient_countries && currentActivityData.recipient_countries.length > 0
        ? currentActivityData.recipient_countries.map(c => {
            const countryCode = c.country?.code;
            const countryData = IATI_COUNTRIES.find(country => country.code === countryCode);
            const countryName = countryData ? countryData.name : (c.country?.name || countryCode);
            return {
              code: countryCode,
              name: `${countryName}${c.percentage ? ` (${c.percentage}%)` : ''}`,
              vocabulary: 'A4 ISO Country'
            };
          })
        : null;
      
      console.log('[XML Import Debug] Current country info:', currentCountryInfo);
      console.log('[XML Import Debug] Current activity data recipient_countries:', currentActivityData.recipient_countries);
      
      // Only add the field if there's either current data or import data
      if (currentCountryInfo || countryInfo) {
        fields.push({
          fieldName: 'Recipient Countries',
          iatiPath: 'iati-activity/recipient-country',
          currentValue: currentCountryInfo,
          importValue: countryInfo,
          selected: shouldSelectField(currentCountryInfo, countryInfo),
          hasConflict: hasConflict(currentCountryInfo, countryInfo),
          tab: 'locations',
          description: 'Countries where activity takes place with percentage allocations (vocabulary: A4)'
        });
      }

      // Always show recipient regions field if there's current data or import data
      const standardRegions = parsedActivity.recipientRegions ? parsedActivity.recipientRegions.filter(r => r.vocabulary !== '99') : [];
      const customRegions = parsedActivity.recipientRegions ? parsedActivity.recipientRegions.filter(r => r.vocabulary === '99') : [];
      
      // Standard regions
      const regionInfo = standardRegions.length > 0
        ? standardRegions.map(r => {
            // Look up the region name from our regions data
            const regionData = IATI_REGIONS.find(region => region.code === r.code);
            const regionName = regionData ? regionData.name : (r.narrative || r.code);
            const vocab = r.vocabulary || '1';
            const vocabName = vocab === '1' ? 'OECD DAC' : vocab === '2' ? 'UN' : 'Custom';
            return {
              code: r.code,
              name: `${regionName}${r.percentage ? ` (${r.percentage}%)` : ''}`,
              vocabulary: `${vocab} ${vocabName}`
            };
          })
        : null;
      
      const currentRegionInfo = currentActivityData.recipient_regions && currentActivityData.recipient_regions.length > 0
        ? currentActivityData.recipient_regions.map(r => {
            const regionCode = r.region?.code;
            const regionData = IATI_REGIONS.find(region => region.code === regionCode);
            const regionName = regionData ? regionData.name : (r.region?.name || regionCode);
            const vocab = r.vocabulary || '1';
            const vocabName = vocab === '1' ? 'OECD DAC' : vocab === '2' ? 'UN' : 'Custom';
            return {
              code: regionCode,
              name: `${regionName}${r.percentage ? ` (${r.percentage}%)` : ''}`,
              vocabulary: `${vocab} ${vocabName}`
            };
          })
        : null;
      
      if (currentRegionInfo || regionInfo) {
        fields.push({
          fieldName: 'Recipient Regions',
          iatiPath: 'iati-activity/recipient-region',
          currentValue: currentRegionInfo,
          importValue: regionInfo,
          selected: shouldSelectField(currentRegionInfo, regionInfo),
          hasConflict: hasConflict(currentRegionInfo, regionInfo),
          tab: 'locations',
          description: 'Standard regions where activity takes place with percentage allocations'
        });
      }
      
      // Custom geographies
      const customInfo = customRegions.length > 0
        ? customRegions.map(r => ({
            code: r.code,
            name: `${r.narrative || r.code}${r.percentage ? ` (${r.percentage}%)` : ''}`,
            vocabulary: `99 Custom`,
            vocabularyUri: r.vocabularyUri || null
          }))
        : null;
      
      const currentCustomInfo = currentActivityData.custom_geographies && currentActivityData.custom_geographies.length > 0
        ? currentActivityData.custom_geographies.map(c => ({
            code: c.code,
            name: `${c.name}${c.percentage ? ` (${c.percentage}%)` : ''}`,
            vocabulary: `99 Custom`,
            vocabularyUri: c.vocabularyUri || null
          }))
        : null;
      
      if (currentCustomInfo || customInfo) {
        fields.push({
          fieldName: 'Custom Geographies',
          iatiPath: 'iati-activity/recipient-region[@vocabulary="99"]',
          currentValue: currentCustomInfo,
          importValue: customInfo,
          selected: shouldSelectField(currentCustomInfo, customInfo),
          hasConflict: hasConflict(currentCustomInfo, customInfo),
          tab: 'locations',
          description: 'Custom geographies where activity takes place with percentage allocations'
        });
      }

      // Detailed Location Elements (Activity Sites)
      if (parsedActivity.locations && parsedActivity.locations.length > 0) {
        parsedActivity.locations.forEach((location: any, locIndex: number) => {
          const locationReachMap: Record<string, string> = {
            '1': 'Activity',
            '2': 'Intended Beneficiaries'
          };
          const exactnessMap: Record<string, string> = {
            '1': 'Exact',
            '2': 'Approximate',
            '3': 'Extrapolated'
          };
          const locationClassMap: Record<string, string> = {
            '1': 'Administrative Region',
            '2': 'Populated Place',
            '3': 'Structure',
            '4': 'Other Topographical Feature'
          };

          // Get current location at this index for comparison
          const currentLocation = currentActivityData.locations && currentActivityData.locations[locIndex];
          
          // Format location to match exact inline pattern of Recipient Countries
          // Pattern: [BADGE] [NAME] [COORDINATES_BADGE] - all inline on one line
          const locationName = location.name || 'Unnamed Location';
          const locationCode = location.ref || `LOC${locIndex + 1}`;
          const coordinates = location.point?.pos ? location.point.pos : '';
          
          // Create inline styled location display matching other geographical fields
          const locationSummary = (
            <div className="flex flex-wrap items-center gap-2">
              {/* Location code badge - matches AF/AG/489/A1 style */}
              <span className="inline-flex items-center rounded bg-gray-100 px-2 py-0.5 text-xs font-medium text-gray-700">
                {locationCode}
              </span>
              
              {/* Location name - matches Afghanistan (25%) style */}
              <span className="text-sm font-medium text-gray-900">
                {locationName}
              </span>
              
              {/* Coordinates as gray pill badge - matches AF/AG style */}
              {coordinates && (
                <span className="inline-flex items-center rounded bg-gray-100 px-2 py-0.5 text-xs font-medium text-gray-700">
                  {coordinates}
                </span>
              )}
            </div>
          );
          
          // Create current value display if location exists
          let currentValueDisplay = null;
          let currentLocationName = '';
          let currentLocationCode = '';
          let currentCoordinates = '';
          
          if (currentLocation) {
            currentLocationName = currentLocation.location_name || 'Unnamed Location';
            // Use location_ref if available, otherwise fall back to id
            currentLocationCode = currentLocation.location_ref || currentLocation.id || `LOC${locIndex + 1}`;
            currentCoordinates = currentLocation.latitude && currentLocation.longitude 
              ? `${currentLocation.latitude} ${currentLocation.longitude}` 
              : '';
            
            currentValueDisplay = (
              <div className="flex flex-wrap items-center gap-2">
                <span className="inline-flex items-center rounded bg-gray-100 px-2 py-0.5 text-xs font-medium text-gray-700">
                  {currentLocationCode}
                </span>
                <span className="text-sm font-medium text-gray-900">
                  {currentLocationName}
                </span>
                {currentCoordinates && (
                  <span className="inline-flex items-center rounded bg-gray-100 px-2 py-0.5 text-xs font-medium text-gray-700">
                    {currentCoordinates}
                  </span>
                )}
              </div>
            );
          }
          
          // Compare location data - ONLY check if coordinates match
          // This allows updating other fields (name, ref, description, etc.) even if coordinates are the same
          // Helper function to normalize coordinates for comparison
          const normalizeCoordinates = (coords: string) => {
            if (!coords) return '';
            // Normalize to single space between lat/long, trim whitespace
            return coords.trim().replace(/\s+/g, ' ');
          };
          
          const locationsMatch = currentLocation && (
            // Only check if coordinates match (normalized comparison)
            (normalizeCoordinates(currentCoordinates) === normalizeCoordinates(coordinates)) ||
            // Both locations have no coordinates (coverage areas without lat/long)
            (!currentCoordinates && !coordinates)
          );
          
          console.log('[XmlImportTab] Location comparison:', {
            locIndex,
            locationName,
            currentLocationName,
            locationRef: location.ref,
            currentLocationRef: currentLocation?.location_ref,
            coordinates,
            currentCoordinates,
            locationsMatch
          });
          
          fields.push({
            fieldName: `Location ${locIndex + 1}`,
            iatiPath: `iati-activity/location[${locIndex + 1}]`,
            currentValue: currentValueDisplay,
            importValue: locationSummary,
            selected: !locationsMatch,  // Only select if locations don't match
            hasConflict: currentLocation && !locationsMatch,  // Conflict if location exists but differs
            tab: 'locations',
            description: location.description || location.activityDescription || 'Activity location with coordinates and metadata',
            isLocationItem: true,
            locationData: location
          });
        });
      }

      // === SECTORS TAB ===
      
      if (parsedActivity.sectors && parsedActivity.sectors.length > 0) {
        const currentSectorsInfo = currentActivityData.sectors && currentActivityData.sectors.length > 0 
          ? currentActivityData.sectors.map(s => ({
              code: s.code,
              name: s.name,
              percentage: s.percentage
            }))
          : null;
        
        // Separate importable sectors from non-DAC sectors
        // vocabulary 1 = OECD DAC, vocabulary 2 = UN, both are importable
        // vocabulary 99 = Custom/Reporting organisation, not importable
        const importableSectors = parsedActivity.sectors.filter(s => !s.vocabulary || s.vocabulary === '1' || s.vocabulary === '2' || s.vocabulary === 'DAC');
        const nonDacSectors = parsedActivity.sectors.filter(s => s.vocabulary === '99');
        
        const importSectorInfo = importableSectors.map(s => {
          // Try to get sector name from DAC sectors data using flexible lookup
          const sectorInfo = s.code ? getSectorInfoFlexible(s.code) : null;
          const sectorName = sectorInfo ? getCleanSectorName(sectorInfo.name) : (s.narrative || 'Unnamed sector');
          
          return {
            code: s.code,
            name: sectorName,
            percentage: s.percentage || 0,
            isDac: true
          };
        });
        
        // Add non-DAC sectors as locked/unimportable
        const nonDacSectorInfo = nonDacSectors.map(s => ({
          code: s.code,
          name: s.narrative || 'Custom sector',
          percentage: s.percentage || 0,
          isDac: false,
          vocabulary: s.vocabulary,
          locked: true
        }));
        
        const allSectorInfo = [...importSectorInfo, ...nonDacSectorInfo];
        
        // Check for 3-digit sectors that need refinement
        const has3DigitSectors = parsedActivity.sectors.some(s => 
          s.code && s.code.length === 3 && /^\d{3}$/.test(s.code)
        );
        console.log('[Sector Import Debug] Parsed sectors:', parsedActivity.sectors);
        console.log('[Sector Import Debug] 3-digit sectors detected:', has3DigitSectors);
        console.log('[Sector Import Debug] Sector codes:', parsedActivity.sectors.map(s => s.code));
        
        const hasConflict = !!currentActivityData.sectors?.length;
        const hasNonDacSectors = nonDacSectors.length > 0;
        const sectorField: ParsedField = {
          fieldName: 'Sectors',
          iatiPath: 'iati-activity/sector',
          currentValue: currentSectorsInfo,
          importValue: allSectorInfo,
          selected: shouldSelectField(currentSectorsInfo, importSectorInfo), // Only select DAC sectors
          hasConflict: hasConflict,
          tab: 'sectors',
          description: hasNonDacSectors 
            ? `Sector classifications and allocations (${nonDacSectors.length} non-DAC sectors excluded)`
            : has3DigitSectors 
            ? 'Sector classifications and allocations (Contains 3-digit categories - refinement needed)'
            : 'Sector classifications and allocations',
          hasNonDacSectors: hasNonDacSectors,
          nonDacSectors: nonDacSectors
        };
        
        // Add metadata to track sectors that need refinement
        if (has3DigitSectors) {
          (sectorField as any).needsRefinement = true;
          // Only pass 3-digit DAC sectors that need refinement, not all sectors
          const sectorsNeedingRefinement = parsedActivity.sectors.filter(s => 
            s.code && s.code.length === 3 && /^\d{3}$/.test(s.code) && 
            (s.vocabulary === '1' || s.vocabulary === '2' || !s.vocabulary)
          );
          (sectorField as any).importedSectors = sectorsNeedingRefinement;
        }
        
        fields.push(sectorField);
      }

      if (parsedActivity.policyMarkers && parsedActivity.policyMarkers.length > 0) {
        // Fetch existing policy markers to populate current values
        let existingPolicyMarkers = [];
        try {
          const policyMarkersResponse = await fetch(`/api/activities/${activityId}/policy-markers`);
          if (policyMarkersResponse.ok) {
            existingPolicyMarkers = await policyMarkersResponse.json();
            console.log('[XML Import] Fetched existing policy markers:', existingPolicyMarkers);
          }
        } catch (error) {
          console.warn('[XML Import] Failed to fetch existing policy markers:', error);
        }

        // Create individual fields for each policy marker
        parsedActivity.policyMarkers.forEach((marker: any, index: number) => {
          // Find matching existing policy marker
          const existingMarker = existingPolicyMarkers.find((existing: any) => 
            existing.policy_marker_details?.code === marker.code && 
            existing.policy_marker_details?.vocabulary === marker.vocabulary
          );

          const currentValue = existingMarker ? {
            code: existingMarker.policy_marker_details?.code,
            significance: existingMarker.significance,
            vocabulary: existingMarker.policy_marker_details?.vocabulary,
            vocabulary_uri: existingMarker.policy_marker_details?.vocabulary_uri,
            rationale: existingMarker.rationale,
            name: existingMarker.policy_marker_details?.name
          } : null;

        fields.push({
            fieldName: `Policy Marker: ${marker.code || 'Unknown'}`,
            iatiPath: `iati-activity/policy-marker[${index}]`,
            currentValue: currentValue,
            importValue: {
              code: marker.code,
              significance: marker.significance,
              vocabulary: marker.vocabulary,
              vocabulary_uri: marker.vocabulary_uri,
              rationale: marker.rationale
            },
          selected: false,
            hasConflict: hasConflict(currentValue, {
              code: marker.code,
              significance: marker.significance,
              vocabulary: marker.vocabulary,
              vocabulary_uri: marker.vocabulary_uri,
              rationale: marker.rationale
            }),
            tab: 'policy-markers',
            description: `Policy marker: ${marker.code} (Significance: ${marker.significance})`,
            isPolicyMarker: true,
            policyMarkerData: marker
          });
        });
      }

      // === PARTNERS TAB ===
      
      if (parsedActivity.reportingOrg) {
        // Get current reporting org from activity data
        const currentReportingOrg = currentActivityData ? {
          name: currentActivityData['created_by_org_name' as keyof typeof currentActivityData] || null,
          acronym: currentActivityData['created_by_org_acronym' as keyof typeof currentActivityData] || null
        } : null;

        fields.push({
          fieldName: 'Reporting Organization',
          iatiPath: 'iati-activity/reporting-org',
          currentValue: currentReportingOrg,
          importValue: {
            name: parsedActivity.reportingOrg.narrative || parsedActivity.reportingOrg.ref,
            ref: parsedActivity.reportingOrg.ref || null,
            narrative: parsedActivity.reportingOrg.narrative || null,
            type: parsedActivity.reportingOrg.type || null
          },
          selected: false,
          hasConflict: false,
          tab: 'reporting_org',
          description: 'Organization reporting this activity'
        });
      }

      if (parsedActivity.participatingOrgs && parsedActivity.participatingOrgs.length > 0) {
        parsedActivity.participatingOrgs.forEach((org: any, index: number) => {
          const orgName = org.narrative || org.ref || 'Unknown Organization';
          const role = org.role || 'Unknown Role';
          
        fields.push({
            fieldName: `Participating Organization: ${orgName}`,
            iatiPath: `iati-activity/participating-org[${index}]`,
          currentValue: null,
            importValue: {
              name: orgName,
              ref: org.ref || null,
              role: role,
              narrative: org.narrative || null,
              type: org.type || null
            },
          selected: false,
          hasConflict: false,
            tab: 'participating_orgs',
            description: `Participating organization: ${orgName} (Role: ${role})`
          });
        });
      }

      // === CONTACTS TAB ===

      if (parsedActivity.contactInfo && parsedActivity.contactInfo.length > 0) {
        parsedActivity.contactInfo.forEach((contact: any, index: number) => {
          const contactType = contact.type || 'Contact';
          const contactName = contact.organization?.narrative || contact.personName?.narrative || 'N/A';
          
        fields.push({
            fieldName: `${contactType}: ${contactName}`,
            iatiPath: `iati-activity/contact-info[${index}]`,
          currentValue: null,
            importValue: {
              type: contactType,
              organization: contact.organization?.narrative || null,
              personName: contact.personName?.narrative || null,
              jobTitle: contact.jobTitle?.narrative || null,
              department: contact.department?.narrative || null,
              email: contact.email || null,
              telephone: contact.telephone || null,
              website: contact.website || null,
              mailingAddress: contact.mailingAddress?.narrative || null
            },
          selected: false,
          hasConflict: false,
            tab: 'contacts',
            description: `${contactType} contact information`
          });
        });
      }

      // === RESULTS TAB ===
      
      if (parsedActivity.results && parsedActivity.results.length > 0) {
        const resultsInfo = parsedActivity.results.map(r => 
          r.title || 'Untitled result'
        ).join('; ');
        fields.push({
          fieldName: 'Results Framework',
          iatiPath: 'iati-activity/result',
          currentValue: null,
          importValue: resultsInfo,
          selected: false,
          hasConflict: false,
          tab: 'results',
          description: 'Results, indicators, and targets'
        });
      }

      if (fields.length === 0) {
        throw new Error('No importable fields found in the XML file. Please check that it contains valid IATI activity data.');
      }

      console.log('[XML Import Debug] Setting parsed fields:', fields.length, 'fields');
      setParsedFields(fields);
      
      // EXTERNAL PUBLISHER DETECTION - After parsing is complete
      console.log('[XML Import] Checking for external publisher...');
      if (fileToCheck) {
        try {
          const meta = await extractIatiMeta(fileToCheck);
          console.log('[XML Import] Extracted metadata:', meta);
          console.log('[XML Import] User publisher refs:', userPublisherRefs);
          
          // Store metadata for display in the modal
          setXmlMetadata(meta);
          
          // Check if reporting org matches user's publisher refs
          const isOwnedActivity = userPublisherRefs.some(ref => 
            ref && meta.reportingOrgRef && 
            ref.toLowerCase() === meta.reportingOrgRef.toLowerCase()
          );
          
          if (!isOwnedActivity) {
            console.log('[XML Import] EXTERNAL PUBLISHER DETECTED!');
            console.log('[XML Import] Reporting org:', meta.reportingOrgRef);
            console.log('[XML Import] User refs:', userPublisherRefs);
            
            // Check if this IATI ID already exists
            let existingAct = null;
            if (meta.iatiId) {
              try {
                const searchResponse = await fetch(`/api/activities/search?iatiId=${encodeURIComponent(meta.iatiId)}`);
                if (searchResponse.ok) {
                  const searchData = await searchResponse.json();
                  if (searchData.activities && searchData.activities.length > 0) {
                    existingAct = searchData.activities[0];
                  }
                }
              } catch (err) {
                console.error('[XML Import] Error checking for existing activity:', err);
              }
            }
            
            // Set up modal data
            setExternalPublisherMeta(meta);
            setExistingActivity(existingAct);
            setShowExternalPublisherModal(true);
            
            // Fields are already parsed and ready
            // Show the modal but also show the preview
            setImportStatus({ stage: 'previewing', progress: 100 });
            toast.info('External publisher detected', {
              description: `This activity is reported by ${meta.reportingOrgName || meta.reportingOrgRef}. Please choose how to handle it before importing.`
            });
            toast.success(`XML file parsed successfully! Found ${fields.length} importable fields.`);
            return; // Exit here, modal is shown and preview is visible
          } else {
            console.log('[XML Import] Activity is owned by user, proceeding with normal import');
          }
        } catch (metaError) {
          console.error('[XML Import] Error extracting metadata:', metaError);
          // Continue with normal import if metadata extraction fails
        }
      }
      
      console.log('[XML Import Debug] Setting status to previewing');
      setImportStatus({ stage: 'previewing', progress: 100 });
      
      // AUTO-TRIGGER SECTOR REFINEMENT for 3-digit sectors
      const sectorField = fields.find(f => f.fieldName === 'Sectors');
      if (sectorField && (sectorField as any).needsRefinement) {
        console.log('[XML Import] Auto-triggering sector refinement for 3-digit sectors');
        const importedSectors = (sectorField as any).importedSectors || [];
        
        // Filter to only include 3-digit DAC sectors that need refinement
        const sectorsNeedingRefinement = importedSectors.filter((s: any) => 
          s.code && s.code.length === 3 && /^\d{3}$/.test(s.code) && 
          (s.vocabulary === '1' || s.vocabulary === '2' || !s.vocabulary)
        );
        
        // Show sector refinement modal immediately
        setSectorRefinementData({
          originalSectors: sectorsNeedingRefinement,
          refinedSectors: []
        });
        setShowSectorRefinement(true);
        
        toast.info('3-digit sectors detected', {
          description: 'Please map these to specific 5-digit subsectors before importing.'
        });
      }
      
      toast.success(`XML file parsed successfully! Found ${fields.length} importable fields.`);
    } catch (error) {
      console.error('[XML Import Debug] Parsing error:', error);
      setImportStatus({ 
        stage: 'error', 
        message: error instanceof Error ? error.message : 'Failed to parse XML file. Please ensure it\'s a valid IATI XML document.' 
      });
      toast.error('Failed to parse XML file', {
        description: error instanceof Error ? error.message : 'Unknown error occurred'
      });
    }
  };

  // Toggle field selection
  const toggleFieldSelection = (index: number, checked?: boolean) => {
    setParsedFields(prev => {
      const updated = [...prev];
      updated[index].selected = checked !== undefined ? checked : !updated[index].selected;
      return updated;
    });
  };

  // Select all fields
  const selectAllFields = (select: boolean) => {
    setParsedFields(prev => prev.map(field => ({ ...field, selected: select })));
  };

  // Handle sector refinement
  const handleSectorRefinement = (importedSectors: any[]) => {
    console.log('[Sector Refinement] Opening refinement dialog for sectors:', importedSectors);
    console.log('[Sector Refinement] Sector count:', importedSectors.length);
    console.log('[Sector Refinement] Sector details:', importedSectors.map(s => ({
      code: s.code,
      narrative: s.narrative,
      percentage: s.percentage,
      codeLength: s.code?.length
    })));
    
    // Filter to only include 3-digit DAC sectors that need refinement
    const sectorsNeedingRefinement = importedSectors.filter(s => 
      s.code && s.code.length === 3 && /^\d{3}$/.test(s.code) && 
      (s.vocabulary === '1' || s.vocabulary === '2' || !s.vocabulary)
    );
    
    setSectorRefinementData({
      originalSectors: sectorsNeedingRefinement,
      refinedSectors: []
    });
    setShowSectorRefinement(true);
  };

  // Import selected fields
  const importSelectedFields = async () => {
    console.log('ðŸš€ [XML Import] Starting import process...');
    const selectedFieldsList = parsedFields.filter(f => f.selected);
    console.log('ðŸ“‹ [XML Import] Selected fields:', selectedFieldsList);
    console.log('ðŸ“‹ [XML Import] Selected fields count:', selectedFieldsList.length);
    
    if (selectedFieldsList.length === 0) {
      toast.error('Please select at least one field to import');
      return;
    }

    setImportStatus({ stage: 'importing', progress: 0 });

    try {
      // Prepare the update data based on selected fields
      const updateData: any = {};
      
      selectedFieldsList.forEach(field => {
        setImportStatus({ 
          stage: 'importing', 
          progress: Math.round((selectedFieldsList.indexOf(field) / selectedFieldsList.length) * 50),
          message: `Preparing ${field.fieldName}...`
        });

        switch (field.fieldName) {
          case 'Activity Title':
            updateData.title_narrative = field.importValue;
            break;
          case 'Activity Description':
            console.log('[Import Update] Setting description_narrative:', field.importValue?.substring(0, 100));
            updateData.description_narrative = field.importValue;
            break;
          case 'Activity Description - Objectives':
            console.log('[Import Update] Setting description_objectives:', field.importValue?.substring(0, 100));
            updateData.description_objectives = field.importValue;
            break;
          case 'Activity Description - Target Groups':
            console.log('[Import Update] Setting description_target_groups:', field.importValue?.substring(0, 100));
            updateData.description_target_groups = field.importValue;
            break;
          case 'Activity Description - Other':
            console.log('[Import Update] Setting description_other:', field.importValue?.substring(0, 100));
            updateData.description_other = field.importValue;
            break;
          case 'Planned Start Date':
            updateData.planned_start_date = field.importValue;
            break;
          case 'Planned End Date':
            updateData.planned_end_date = field.importValue;
            break;
          case 'Actual Start Date':
            updateData.actual_start_date = field.importValue;
            break;
          case 'Actual End Date':
            updateData.actual_end_date = field.importValue;
            break;
          case 'Activity Status':
            updateData.activity_status = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'Collaboration Type':
            updateData.collaboration_type = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'IATI Identifier':
            updateData.iati_identifier = field.importValue;
            break;
          case 'Activity Scope':
            updateData.activity_scope = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'Narrative Language':
            updateData.language = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'Default Currency':
            updateData.default_currency = field.importValue;
            break;
          case 'Default Finance Type':
            updateData.default_finance_type = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'Default Flow Type':
            updateData.default_flow_type = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'Default Aid Type':
            updateData.default_aid_type = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'Default Tied Status':
            updateData.default_tied_status = typeof field.importValue === 'object' ? field.importValue.code : field.importValue;
            break;
          case 'Sectors':
            // Handle sector imports - this will be processed separately after main activity update
            updateData._importSectors = true;
            break;
          case 'Recipient Countries':
            // Handle recipient countries import
            if (parsedActivity.recipientCountries && parsedActivity.recipientCountries.length > 0) {
              updateData.recipient_countries = parsedActivity.recipientCountries.map((country: any) => {
                const countryData = IATI_COUNTRIES.find(c => c.code === country.code);
                const countryName = countryData ? countryData.name : (country.narrative || country.code);
                
                return {
                id: `country-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                country: {
                  code: country.code,
                    name: countryName,
                  iso2: country.code,
                  withdrawn: false
                },
                  percentage: country.percentage || 0,
                  vocabulary: 'A4', // Default to ISO Country vocabulary
                  vocabularyUri: undefined,
                  narrative: country.narrative || undefined
                };
              });
            }
            break;
          case 'Recipient Regions':
            // Handle recipient regions import
            if (parsedActivity.recipientRegions && parsedActivity.recipientRegions.length > 0) {
              const regions: any[] = [];
              const customGeographies: any[] = [];
              
              parsedActivity.recipientRegions.forEach((region: any) => {
                const regionData = {
                id: `region-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                region: {
                  code: region.code,
                    name: (() => {
                      const regionLookup = IATI_REGIONS.find(r => r.code === region.code);
                      return regionLookup ? regionLookup.name : (region.narrative || region.code);
                    })(),
                  vocabulary: region.vocabulary || '1',
                  withdrawn: false
                },
                  percentage: region.percentage || 0,
                  vocabulary: region.vocabulary || '1',
                  vocabularyUri: undefined,
                  narrative: region.narrative || undefined
                };
                
                // Check if this is a custom geography (vocabulary="99")
                if (region.vocabulary === '99') {
                  customGeographies.push({
                    id: `custom-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    name: region.narrative || region.code,
                    code: region.code,
                    percentage: region.percentage || 0,
                    vocabularyUri: region.vocabularyUri || null,
                    narrative: region.narrative || undefined
                  });
                } else {
                  // For standard regions, update vocabularyUri if present
                  regionData.vocabularyUri = region.vocabularyUri;
                  regions.push(regionData);
                }
              });
              
              if (regions.length > 0) {
                updateData.recipient_regions = regions;
              }
              if (customGeographies.length > 0) {
                updateData.custom_geographies = customGeographies;
              }
            }
            break;
          case 'Custom Geographies':
            // Handle custom geographies import (vocabulary="99" regions)
            if (parsedActivity.recipientRegions && parsedActivity.recipientRegions.length > 0) {
              const customRegions = parsedActivity.recipientRegions.filter((region: any) => region.vocabulary === '99');
              if (customRegions.length > 0) {
                updateData.custom_geographies = customRegions.map((region: any) => ({
                  id: `custom-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                  name: region.narrative || region.code,
                  code: region.code,
                  percentage: region.percentage || 0,
                  vocabularyUri: region.vocabularyUri || null,
                  narrative: region.narrative || undefined
                }));
              }
            }
            break;
          case 'Policy Markers':
            // Handle policy markers import - this will be processed separately after main activity update
              updateData._importPolicyMarkers = true;
            break;
          default:
            if (field.fieldName.startsWith('Participating Organization:')) {
              // Collect participating organization data for import
              if (!updateData.importedParticipatingOrgs) updateData.importedParticipatingOrgs = [];
              updateData.importedParticipatingOrgs.push(field.importValue);
              console.log(`[XML Import] Adding participating organization for import:`, field.importValue);
            } else
            if (field.fieldName.startsWith('Policy Marker:')) {
              // Handle individual policy marker import
              if (!updateData._importPolicyMarkers) updateData._importPolicyMarkers = [];
              updateData._importPolicyMarkers.push(field.policyMarkerData);
            } else if (field.fieldName.startsWith('Budget ')) {
              // Collect budget data for import
              if (!updateData.importedBudgets) updateData.importedBudgets = [];
              const budgetIndex = parseInt(field.fieldName.split(' ')[1]) - 1;
              if (parsedActivity.budgets && parsedActivity.budgets[budgetIndex]) {
                updateData.importedBudgets.push(parsedActivity.budgets[budgetIndex]);
              }
              console.log(`[XML Import] Adding budget ${budgetIndex + 1} for import`);
            } else if (field.fieldName.startsWith('Planned Disbursement ')) {
              // Collect planned disbursement data for import
              if (!updateData.importedPlannedDisbursements) updateData.importedPlannedDisbursements = [];
              const disbursementIndex = parseInt(field.fieldName.split(' ')[2]) - 1;
              if (parsedActivity.plannedDisbursements && parsedActivity.plannedDisbursements[disbursementIndex]) {
                updateData.importedPlannedDisbursements.push(parsedActivity.plannedDisbursements[disbursementIndex]);
              }
              console.log(`[XML Import] Adding planned disbursement ${disbursementIndex + 1} for import`);
            } else if (field.fieldName.startsWith('Transaction ')) {
              // Collect transaction data for import
              if (!updateData.importedTransactions) updateData.importedTransactions = [];
              const transactionIndex = parseInt(field.fieldName.split(' ')[1]) - 1;
              if (parsedActivity.transactions && parsedActivity.transactions[transactionIndex]) {
                updateData.importedTransactions.push(parsedActivity.transactions[transactionIndex]);
              }
              console.log(`[XML Import] Adding transaction ${transactionIndex + 1} for import`);
            } else if (field.fieldName.startsWith('Location ')) {
              // Collect location data for import
              if (!updateData.importedLocations) updateData.importedLocations = [];
              const locationIndex = parseInt(field.fieldName.split(' ')[1]) - 1;
              if (parsedActivity.locations && parsedActivity.locations[locationIndex]) {
                updateData.importedLocations.push(parsedActivity.locations[locationIndex]);
              }
              console.log(`[XML Import] Adding location ${locationIndex + 1} for import`);
            }
            break;
        }
      });

      setImportStatus({ 
        stage: 'importing', 
        progress: 75,
        message: 'Saving to database...'
      });

      // Make API call to update the activity
      console.log('[XML Import] Making API call with data:', updateData);
      console.log('[XML Import] API URL:', `/api/activities/${activityId}`);
      
      const response = await fetch(`/api/activities/${activityId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updateData),
      });

      console.log('[XML Import] API Response status:', response.status);
      console.log('[XML Import] API Response ok:', response.ok);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('[XML Import] API Error response:', errorText);
        throw new Error(`Failed to update activity: ${response.statusText}`);
      }

      // Handle sector imports if any
      if (updateData._importSectors) {
        console.log('[XML Import] Processing sector imports...');
        setImportStatus({ 
          stage: 'importing', 
          progress: 85,
          message: 'Importing sectors...'
        });

        const sectorField = selectedFieldsList.find(f => f.fieldName === 'Sectors');
        if (sectorField) {
          let sectorsToImport = [];
          
          // Check if we have refined sectors
          if ((sectorField as any).refinedSectors && (sectorField as any).refinedSectors.length > 0) {
            console.log('[XML Import] Using refined sectors:', (sectorField as any).refinedSectors);
            sectorsToImport = (sectorField as any).refinedSectors.map((sector: any) => ({
              sector_code: sector.code,
              sector_name: sector.name,
              percentage: sector.percentage,
              type: 'secondary', // Default to secondary for imports
              level: 'subsector' // Refined sectors are always 5-digit subsectors
            }));
          } else if (savedRefinedSectors.length > 0) {
            console.log('[XML Import] Using saved refined sectors:', savedRefinedSectors);
            sectorsToImport = savedRefinedSectors.map((sector: any) => ({
              sector_code: sector.code,
              sector_name: sector.name,
              percentage: sector.percentage,
              type: 'secondary',
              level: 'subsector'
            }));
          } else {
            // Use original sectors from import if no refinement was done
            // Filter out locked (non-DAC) sectors
            console.log('[XML Import] Using original sectors from field');
            const importableSectors = (sectorField.importValue || []).filter((sector: any) => !sector.locked);
            sectorsToImport = importableSectors.map((sector: any) => ({
              sector_code: sector.code,
              sector_name: sector.name,
              percentage: sector.percentage,
              type: 'secondary',
              level: 'subsector'
            }));
          }

          if (sectorsToImport.length > 0) {
            console.log('[XML Import] Importing sectors to database:', sectorsToImport);
            
            // Validate sectors before sending to API
            const totalPercentage = sectorsToImport.reduce((sum: number, s: any) => sum + (s.percentage || 0), 0);
            if (Math.abs(totalPercentage - 100) > 0.01) {
              console.error('[XML Import] Invalid sector percentage total:', totalPercentage);
              toast.error('Sector import failed: Invalid percentages', {
                description: `Sector percentages total ${totalPercentage.toFixed(1)}% instead of 100%. Please use the sector refinement modal to fix this.`
              });
              return;
            }
            
            // Check for invalid sector codes
            const invalidSectors = sectorsToImport.filter((s: any) => !s.sector_code || !/^\d{5}$/.test(s.sector_code));
            if (invalidSectors.length > 0) {
              console.error('[XML Import] Invalid sector codes found:', invalidSectors);
              toast.error('Sector import failed: Invalid codes', {
                description: `${invalidSectors.length} sectors have invalid codes. Valid sector codes must be 5-digit numbers.`
              });
              return;
            }
            
            try {
              const sectorResponse = await fetch(`/api/activities/${activityId}/sectors`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ sectors: sectorsToImport, replace: true }),
              });

              if (!sectorResponse.ok) {
                const errorData = await sectorResponse.json();
                console.error('[XML Import] Sector import API error:', errorData);
                
                if (sectorResponse.status === 400 && errorData.error?.includes('percentage')) {
                  toast.error('Sector import failed: Percentage error', {
                    description: errorData.error || 'Sector percentages must total exactly 100%'
                  });
                } else {
                  toast.error('Failed to import sectors', {
                    description: `API Error: ${errorData.error || sectorResponse.statusText}. Main activity data was imported successfully.`
                  });
                }
              } else {
                const successData = await sectorResponse.json();
                console.log('[XML Import] Sectors imported successfully:', successData);
                toast.success(`Sectors imported successfully`, {
                  description: `${sectorsToImport.length} sector(s) added to the activity`
                });
              }
            } catch (sectorError) {
              console.error('[XML Import] Sector import network error:', sectorError);
              toast.error('Failed to import sectors', {
                description: 'Network error occurred while importing sectors. Please check your connection and try again.'
              });
            }
          } else {
            console.log('[XML Import] No sectors to import');
          }
        }
      }

      // Handle locations import if any
      if (updateData.importedLocations && updateData.importedLocations.length > 0) {
        console.log('[XML Import] Processing locations import...');
        setImportStatus({ 
          stage: 'importing', 
          progress: 87,
          message: 'Geocoding coordinates and importing locations...'
        });

        try {
          // Process locations and add reverse geocoding for coordinates
          const locationsToImport = await Promise.all(
            updateData.importedLocations.map(async (loc: any) => {
              // Parse coordinates if present
              let latitude = null;
              let longitude = null;
              if (loc.point?.pos) {
                const coords = loc.point.pos.split(' ');
                if (coords.length === 2) {
                  latitude = parseFloat(coords[0]);
                  longitude = parseFloat(coords[1]);
                }
              }
              
              // Determine location type
              const locationType = (latitude && longitude) ? 'site' : 'coverage';
              
              const locationData: any = {
                location_type: locationType,
                location_name: loc.name || 'Unnamed Location',
                description: loc.description,
                location_description: loc.description,
                activity_location_description: loc.activityDescription,
                srs_name: loc.point?.srsName || 'http://www.opengis.net/def/crs/EPSG/0/4326',
                location_ref: loc.ref || undefined,  // IATI location reference (ref attribute)
                location_reach: loc.locationReach || undefined,  // Keep as string
                exactness: loc.exactness || undefined,  // Keep as string
                location_class: loc.locationClass || undefined,  // Keep as string
                feature_designation: loc.featureDesignation,
                location_id_vocabulary: loc.locationId?.vocabulary,
                location_id_code: loc.locationId?.code,
                admin_vocabulary: loc.administrative?.vocabulary,
                admin_level: loc.administrative?.level,  // Keep as string
                admin_code: loc.administrative?.code,
                source: 'import',
                validation_status: 'valid'
              };

              // Add site-specific fields
              if (locationType === 'site' && latitude && longitude) {
                locationData.latitude = latitude;
                locationData.longitude = longitude;

                // Perform reverse geocoding to populate address fields
                try {
                  console.log(`[XML Import] Reverse geocoding coordinates: ${latitude}, ${longitude}`);
                  const geocodeResponse = await fetch(`/api/geocoding/reverse?lat=${latitude}&lon=${longitude}`);
                  
                  if (geocodeResponse.ok) {
                    const geocodeData = await geocodeResponse.json();
                    console.log('[XML Import] Geocoding result:', geocodeData);
                    
                    // Populate address fields from geocoding
                    if (geocodeData.address) {
                      locationData.address = geocodeData.display_name;
                      locationData.city = geocodeData.address.city || 
                                         geocodeData.address.town || 
                                         geocodeData.address.village;
                      locationData.postal_code = geocodeData.address.postcode;
                      locationData.country_code = geocodeData.address.country_code?.toUpperCase();
                      
                      // Myanmar-specific admin boundaries
                      locationData.state_region_name = geocodeData.address.state || 
                                                       geocodeData.address.province;
                      locationData.township_name = geocodeData.address.county || 
                                                  geocodeData.address.municipality;
                      locationData.district_name = geocodeData.address.district;
                      locationData.village_name = geocodeData.address.village || 
                                                 geocodeData.address.hamlet;
                      
                      console.log('[XML Import] Address fields populated from geocoding');
                    }
                  } else {
                    console.warn('[XML Import] Reverse geocoding failed, continuing without address data');
                  }
                } catch (geocodeError) {
                  console.error('[XML Import] Geocoding error:', geocodeError);
                  // Continue import even if geocoding fails
                }
              }

              // Add coverage-specific fields
              if (locationType === 'coverage') {
                locationData.coverage_scope = 'regional'; // Default for imported coverage areas
              }

              return locationData;
            })
          );

          console.log('[XML Import] Importing locations to database:', locationsToImport);
          
          const locationsResponse = await fetch(`/api/activities/${activityId}/locations`, {
            method: 'PUT',  // Changed from POST to PUT for batch import
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ locations: locationsToImport }),
          });

          if (!locationsResponse.ok) {
            const errorData = await locationsResponse.json();
            console.error('[XML Import] Locations import API error:', errorData);
            toast.error('Failed to import locations', {
              description: errorData.error || 'Could not import location data. Main activity data was imported successfully.'
            });
          } else {
            const successData = await locationsResponse.json();
            console.log('[XML Import] Locations imported successfully:', successData);
            toast.success(`Locations imported successfully`, {
              description: `${locationsToImport.length} location(s) added to the activity`
            });
          }
        } catch (locationError) {
          console.error('[XML Import] Locations import network error:', locationError);
          toast.error('Failed to import locations', {
            description: 'Network error occurred while importing locations. Please check your connection and try again.'
          });
        }
      }

      // Handle policy markers import if any
      if (updateData._importPolicyMarkers) {
        captureConsoleLog('[XML Import] Processing policy markers import...');
        setImportStatus({ 
          stage: 'importing', 
          progress: 90,
          message: 'Importing policy markers...'
        });

        try {
          // First, fetch available policy markers from database to match IATI codes
          captureConsoleLog(`[XML Import] Fetching policy markers for activity: ${activityId}`);
          const policyMarkersResponse = await fetch(`/api/policy-markers?activity_id=${activityId}`);
          
          if (!policyMarkersResponse.ok) {
            const errorText = await policyMarkersResponse.text();
            captureConsoleLog(`[XML Import] Policy markers API error: ${policyMarkersResponse.status} - ${errorText}`);
            throw new Error(`Failed to fetch policy markers: ${policyMarkersResponse.status} ${errorText}`);
          }
          
            const availableMarkers = await policyMarkersResponse.json();
          captureConsoleLog(`[XML Import] Received ${availableMarkers.length} available markers from API`);
            
            const importedPolicyMarkers = [];
            
            // Determine which policy markers to process
            let markersToProcess = [];
            if (Array.isArray(updateData._importPolicyMarkers)) {
              // Individual selections
              markersToProcess = updateData._importPolicyMarkers;
              captureConsoleLog(`[XML Import] Processing ${markersToProcess.length} individually selected policy markers`);
            } else if (updateData._importPolicyMarkers === true) {
              // Bulk import all policy markers
              markersToProcess = parsedActivity.policyMarkers || [];
              captureConsoleLog(`[XML Import] Processing all ${markersToProcess.length} policy markers from XML`);
            }
            
            for (const xmlMarker of markersToProcess) {
            captureConsoleLog(`[XML Import DEBUG] Processing XML marker:`, xmlMarker);
            captureConsoleLog(`[XML Import DEBUG] Available markers:`, availableMarkers.map((m: any) => ({
                uuid: m.uuid,
                code: m.code,
                iati_code: m.iati_code,
                name: m.name,
                vocabulary: m.vocabulary,
                is_iati_standard: m.is_iati_standard
              })));
            captureConsoleLog(`[XML Import DEBUG] Standard IATI markers:`, availableMarkers.filter((m: any) => m.is_iati_standard).map((m: any) => ({
              code: m.code,
              iati_code: m.iati_code,
              name: m.name
            })));
            captureConsoleLog(`[XML Import DEBUG] XML marker details:`, {
                code: xmlMarker.code,
                vocabulary: xmlMarker.vocabulary,
                vocabulary_uri: xmlMarker.vocabulary_uri,
                significance: xmlMarker.significance,
                narrative: xmlMarker.narrative
              });

              // Determine lookup strategy based on vocabulary
              let matchingMarker = null;
              const markerVocabulary = xmlMarker.vocabulary || '1';

              if (markerVocabulary === '1') {
                // Standard IATI marker: match by vocabulary + iati_code
              captureConsoleLog(`[XML Import DEBUG] Looking for standard marker with iati_code="${xmlMarker.code}"`);
              matchingMarker = availableMarkers.find((marker: any) => {
                const matches = marker.is_iati_standard === true &&
                  marker.vocabulary === '1' &&
                  marker.iati_code === xmlMarker.code;
                if (matches) {
                  captureConsoleLog(`[XML Import DEBUG] Found matching standard marker:`, marker);
                }
                return matches;
              });
              } else if (markerVocabulary === '99') {
                // Custom marker: match by vocabulary + code + vocabulary_uri
                const vocabularyUri = xmlMarker.vocabulary_uri || '';
              captureConsoleLog(`[XML Import DEBUG] Looking for custom marker with code="${xmlMarker.code}", vocabulary_uri="${vocabularyUri}"`);
              matchingMarker = availableMarkers.find((marker: any) => {
                const matches = marker.is_iati_standard === false &&
                  marker.vocabulary === '99' &&
                  marker.code === xmlMarker.code &&
                  (marker.vocabulary_uri || '') === vocabularyUri;
                if (matches) {
                  captureConsoleLog(`[XML Import DEBUG] Found matching custom marker:`, marker);
                }
                return matches;
              });
            }

            captureConsoleLog(`[XML Import DEBUG] Matching result for code ${xmlMarker.code}:`,
                matchingMarker ? { uuid: matchingMarker.uuid, code: matchingMarker.code, name: matchingMarker.name, iati_code: matchingMarker.iati_code } : 'NO MATCH');

              if (matchingMarker) {
                // Convert significance from string to number
                const rawSignificance = parseInt(xmlMarker.significance || '0');

                // Normalize significance to IATI-compliant range
                const { validatePolicyMarkerSignificance } = await import('@/lib/policy-marker-validation');
                const validation = validatePolicyMarkerSignificance(matchingMarker, rawSignificance);
                
                let significance = rawSignificance;
                if (!validation.isValid) {
                  // Normalize to maximum allowed significance
                  significance = validation.maxAllowedSignificance;
                  captureConsoleLog(`[XML Import] Normalized significance for ${matchingMarker.name}: ${rawSignificance} -> ${significance} (IATI compliance)`);
                }

                captureConsoleLog(`âœ… [XML Import FIELD] PROCESSED ${matchingMarker.name} (code: ${xmlMarker.code}) - significance: ${significance}`);

                importedPolicyMarkers.push({
                  policy_marker_id: matchingMarker.uuid, // Use UUID, not ID!
                  significance: significance,
                  rationale: xmlMarker.narrative || null
                });

              captureConsoleLog(`[XML Import] Mapped policy marker: ${xmlMarker.code} -> ${matchingMarker.name} (significance: ${significance})`);
            } else {
                // Create custom policy marker if not found
              captureConsoleLog(`[XML Import] Creating custom policy marker for code: ${xmlMarker.code}, vocabulary: 99`);

                try {
                  // Create custom policy marker
                  const createResponse = await fetch('/api/policy-markers', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                    },
                  body: JSON.stringify({
                    name: `Policy Marker ${xmlMarker.code}`,
                    description: `Custom policy marker imported from XML (code: ${xmlMarker.code})`,
                    marker_type: 'custom',
                    code: xmlMarker.code,
                    vocabulary: '99',
                    vocabulary_uri: xmlMarker.vocabulary_uri || null
                  })
                  });

                  if (createResponse.ok) {
                    const newMarker = await createResponse.json();
                  captureConsoleLog(`[XML Import] Successfully created custom policy marker:`, newMarker);

                    // Convert significance from string to number
                    const rawSignificance = parseInt(xmlMarker.significance || '0');

                  // Validate significance according to IATI rules
                    const { validatePolicyMarkerSignificance } = await import('@/lib/policy-marker-validation');
                    const validation = validatePolicyMarkerSignificance(newMarker, rawSignificance);

                    let significance = rawSignificance;
                    if (!validation.isValid) {
                      // Normalize to maximum allowed significance
                      significance = validation.maxAllowedSignificance;
                      captureConsoleLog(`[XML Import] Normalized significance for custom marker ${xmlMarker.code}: ${rawSignificance} -> ${significance} (IATI compliance)`);
                    }

                    // Add the newly created marker to our import list
                    importedPolicyMarkers.push({
                      policy_marker_id: newMarker.uuid, // Use UUID!
                      significance: significance,
                      rationale: xmlMarker.narrative || null
                    });

                  captureConsoleLog(`[XML Import] Created and assigned custom policy marker: ${xmlMarker.code} -> ${newMarker.name} (significance: ${significance})`);
                    } else {
                      const errorData = await createResponse.json().catch(() => ({ error: 'Unknown error' }));
                  captureConsoleLog(`[XML Import] Failed to create custom policy marker:`, errorData);
                      toast.warning(`Failed to create custom policy marker "${xmlMarker.code}"`, {
                        description: errorData.error || 'Could not create custom policy marker during import.'
                      });
                    }
                  } catch (createError) {
                captureConsoleLog(`[XML Import] Error creating custom policy marker:`, createError);
                    toast.warning(`Failed to create custom policy marker "${xmlMarker.code}"`, {
                      description: 'Network error occurred while creating custom policy marker.'
                    });
                  }
              }
            }
            
            if (importedPolicyMarkers.length > 0) {
            captureConsoleLog(`\nðŸ“¤ [XML Import] Sending ${importedPolicyMarkers.length} policy markers to API:`);
            importedPolicyMarkers.forEach((marker, index) => {
              captureConsoleLog(`  ${index + 1}. UUID: ${marker.policy_marker_id}, Significance: ${marker.significance}, Rationale: ${marker.rationale || 'none'}`);
            });
            
            captureConsoleLog(`[XML Import] Sending policy markers to API:`, importedPolicyMarkers);
              const importResponse = await fetch(`/api/activities/${activityId}/policy-markers`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                  policyMarkers: importedPolicyMarkers, 
                  replace: true 
                }),
              });

              if (!importResponse.ok) {
              const errorText = await importResponse.text();
              captureConsoleLog('[XML Import] Policy markers import failed:', {
                status: importResponse.status,
                statusText: importResponse.statusText,
                error: errorText
              });
              
              let errorMessage = 'Policy markers could not be imported. Main activity data was imported successfully.';
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorData.details || errorMessage;
              } catch (e) {
                errorMessage = errorText || errorMessage;
              }
              
                toast.error('Failed to import policy markers', {
                description: errorMessage
                });
              } else {
                const successData = await importResponse.json();
              captureConsoleLog('[XML Import] Policy markers imported successfully:', successData);
                toast.success(`Policy markers imported successfully`, {
                  description: `${importedPolicyMarkers.length} policy marker(s) added to the activity`
                });
              }
            } else {
            captureConsoleLog('[XML Import] No policy markers could be matched for import');
            toast.warning('No policy markers imported', {
              description: 'No policy markers from the XML could be matched with available policy markers in the database.'
            });
          }
        } catch (policyMarkersError: any) {
          captureConsoleLog('[XML Import] Policy markers import error:', policyMarkersError);
          captureConsoleLog('[XML Import] Error details:', {
            message: policyMarkersError.message,
            stack: policyMarkersError.stack,
            name: policyMarkersError.name
          });
          toast.error('Failed to import policy markers', {
            description: `An error occurred while processing policy markers: ${policyMarkersError.message}`
          });
        }
      }

      // Update local activity data to reflect changes
      setCurrentActivityData(prev => ({
        ...prev,
        ...updateData
      }));

      // Trigger autosave indicators for imported fields
      if (typeof window !== 'undefined' && user?.id) {
        selectedFieldsList.forEach(field => {
          // Map field names to their localStorage keys for autosave indicators
          let saveKey = '';
          switch (field.fieldName) {
            case 'Activity Title':
              saveKey = 'title';
              break;
            case 'Activity Description':
              saveKey = 'description';
              break;
            case 'Activity Description - Objectives':
              saveKey = 'descriptionObjectives';
              break;
            case 'Activity Description - Target Groups':
              saveKey = 'descriptionTargetGroups';
              break;
            case 'Activity Description - Other':
              saveKey = 'descriptionOther';
              break;
            case 'Activity Status':
              saveKey = 'activityStatus';
              break;
            case 'Collaboration Type':
              saveKey = 'collaborationType';
              break;
            case 'Activity Scope':
              saveKey = 'activityScope';
              break;
            case 'Narrative Language':
              saveKey = 'language';
              break;
            case 'Default Currency':
              saveKey = 'defaultCurrency';
              break;
            case 'Default Aid Type':
              saveKey = 'defaultAidType';
              break;
            case 'Default Finance Type':
              saveKey = 'defaultFinanceType';
              break;
            case 'Default Flow Type':
              saveKey = 'defaultFlowType';
              break;
            case 'Default Tied Status':
              saveKey = 'defaultTiedStatus';
              break;
            case 'Planned Start Date':
              saveKey = 'plannedStartDate';
              console.log(`[XML Import] Date field mapping: ${field.fieldName} -> ${saveKey} with value: ${field.importValue}`);
              break;
            case 'Planned End Date':
              saveKey = 'plannedEndDate';
              console.log(`[XML Import] Date field mapping: ${field.fieldName} -> ${saveKey} with value: ${field.importValue}`);
              break;
            case 'Actual Start Date':
              saveKey = 'actualStartDate';
              console.log(`[XML Import] Date field mapping: ${field.fieldName} -> ${saveKey} with value: ${field.importValue}`);
              break;
            case 'Actual End Date':
              saveKey = 'actualEndDate';
              console.log(`[XML Import] Date field mapping: ${field.fieldName} -> ${saveKey} with value: ${field.importValue}`);
              break;
            case 'Recipient Countries':
              saveKey = 'recipient_countries';
              break;
            case 'Recipient Regions':
              saveKey = 'recipient_regions';
              break;
            default:
              // For other fields, use a generic key
              saveKey = field.fieldName.toLowerCase().replace(/\s+/g, '_');
          }
          
          if (saveKey) {
            console.log(`[XML Import] Marking field as saved: ${saveKey}`);
            setFieldSaved(activityId, user.id, saveKey);
          }
        });
        
        console.log('[XML Import] All imported fields marked as saved - green ticks should appear');
        
        // Trigger a gentle refresh to show the green ticks
        setTimeout(() => {
          window.dispatchEvent(new Event('storage'));
        }, 100);
      }

      setImportStatus({ stage: 'complete' });
      toast.success(`Successfully imported ${selectedFieldsList.length} fields from XML`, {
        description: 'Activity data has been updated and saved to the database.'
      });

      // Clear refined sectors after successful import
      setSavedRefinedSectors([]);

      // Re-fetch activity data to get updated locations for subsequent imports
      console.log('[XML Import] Re-fetching activity data after successful import');
      setRefetchTrigger(prev => prev + 1);

      // Trigger a page refresh after a short delay to ensure all components get fresh data
      setTimeout(() => {
        console.log('[XML Import] Refreshing page to show updated data');
        window.location.reload();
      }, 1500);

    } catch (error) {
      console.error('Import error:', error);
      setImportStatus({ 
        stage: 'error', 
        message: 'Import failed. Please try again.' 
      });
      toast.error('Import failed', {
        description: error instanceof Error ? error.message : 'Unknown error occurred'
      });
    }
  };

  // Reset import
  const resetImport = () => {
    setSelectedFile(null);
    setParsedFields([]);
    setImportStatus({ stage: 'idle' });
    setXmlContent('');
    setShowXmlPreview(false);
    setXmlUrl('');
    setImportMethod('file');
    setXmlMetadata(null);
    // Clear cache for this activity
    if (activityId) {
      parsedXmlCache.delete(activityId);
    }
  };

  // Helper function to organize fields by tabs
  const organizeFieldsByTabs = (fields: ParsedField[]): TabSection[] => {
    const tabMap = new Map<string, TabSection>();
    
    // Define tab display names
    const tabNames: Record<string, string> = {
      'basic': 'General',
      'policy-markers': 'Policy Markers',
      'finances': 'Finances', // This will be the main finances tab
      'locations': 'Locations',
      'sectors': 'Sectors',
      'partners': 'Partners',
      'contacts': 'Contacts',
      'results': 'Results'
    };

    // Financial tabs that should be grouped under main Finances tab
    const financialTabs = ['finances', 'budgets', 'planned_disbursements', 'transactions'];
    
    // Partner tabs that should be grouped under main Partners tab
    const partnerTabs = ['reporting_org', 'participating_orgs'];

    fields.forEach(field => {
      let tabKey = field.tab;
      
      // Group financial tabs under main 'finances' tab
      if (financialTabs.includes(field.tab)) {
        tabKey = 'finances';
      }
      
      // Group partner tabs under main 'partners' tab
      if (partnerTabs.includes(field.tab)) {
        tabKey = 'partners';
      }
      
      if (!tabMap.has(tabKey)) {
        tabMap.set(tabKey, {
          tabId: tabKey,
          tabName: tabNames[tabKey] || tabKey,
          fields: []
        });
      }
      tabMap.get(tabKey)!.fields.push(field);
    });

    return Array.from(tabMap.values()).sort((a, b) => {
      const order = ['basic', 'partners', 'contacts', 'sectors', 'policy-markers', 'locations', 'finances', 'results'];
      return order.indexOf(a.tabId) - order.indexOf(b.tabId);
    });
  };

  // Individual field row component for table display
  const FieldRow = ({ field, globalIndex }: { field: ParsedField; globalIndex: number }) => (
    <tr className="bg-white hover:bg-gray-50">
      <td className="px-4 py-3 text-center">
        <Switch
          checked={field.selected}
          onCheckedChange={(checked) => toggleFieldSelection(globalIndex, checked)}
        />
      </td>
      <td className="px-4 py-3 w-32">
        <div>
          <p className="font-medium text-sm text-gray-900">{field.fieldName}</p>
          {(field as any).needsRefinement && (
            <div className="mt-2">
              <Button
                size="sm"
                variant="outline"
                onClick={() => handleSectorRefinement((field as any).importedSectors)}
                className="text-xs"
              >
                <Settings className="h-3 w-3 mr-1" />
                Refine Sectors
              </Button>
            </div>
          )}
          {field.isFinancialItem && (
            <div className="mt-2">
              <Button
                size="sm"
                variant="outline"
                onClick={() => openFinancialDetailModal(field)}
                className="text-xs"
              >
                <Eye className="h-3 w-3 mr-1" />
                Select Fields
              </Button>
            </div>
          )}
        </div>
      </td>
      <td className="px-4 py-3 w-40">
        <div className="space-y-1">
        {(() => {
          const currentValue = typeof field.currentValue === 'function' ? field.currentValue() : field.currentValue;
          return currentValue ? (
            Array.isArray(currentValue) ? (
              currentValue.map((item, index) => (
                <div key={index} className="flex flex-col gap-1">
                  <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                    <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{item.code}</span>
                    <span className="text-sm font-medium text-gray-900">{item.name}</span>
                    {item.percentage && (
                      <span className="text-xs text-gray-500 font-normal">({Number(item.percentage).toFixed(2)}%)</span>
                    )}
                    {item.vocabulary && (
                      <>
                        <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{item.vocabulary.split(' ')[0]}</span>
                        <span className="text-xs text-gray-400 font-normal ml-1">{item.vocabulary.split(' ').slice(1).join(' ')}</span>
                      </>
                    )}
                  </div>
                </div>
              ))
            ) : field.isPolicyMarker ? (
              <div className="flex flex-col gap-1">
                <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                  <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{currentValue.code}</span>
                  <span className="text-sm font-medium text-gray-900">Policy Marker</span>
                </div>
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Significance:</span>
                  <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{currentValue.significance}</span>
                  {currentValue.vocabulary && (
                    <>
                      <span className="text-xs text-gray-500 ml-2">Vocabulary:</span>
                      <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{currentValue.vocabulary}</span>
                    </>
                  )}
                </div>
                {currentValue.rationale && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Rationale:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.rationale}</span>
                  </div>
                )}
              </div>
            ) : field.tab === 'contacts' && typeof currentValue === 'object' ? (
              <div className="flex flex-col gap-1">
                <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                  <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{currentValue.type}</span>
                  <span className="text-sm font-medium text-gray-900">Contact</span>
                </div>
                {currentValue.organization && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Organization:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.organization}</span>
                  </div>
                )}
                {currentValue.personName && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Person:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.personName}</span>
                  </div>
                )}
                {currentValue.jobTitle && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Title:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.jobTitle}</span>
                  </div>
                )}
                {currentValue.email && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Email:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.email}</span>
                  </div>
                )}
                {currentValue.telephone && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Phone:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.telephone}</span>
                  </div>
                )}
              </div>
            ) : field.tab === 'participating_orgs' && typeof currentValue === 'object' ? (
              <div className="flex flex-col gap-1">
                <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                  <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{currentValue.role}</span>
                  <span className="text-sm font-medium text-gray-900">Participating Org</span>
                </div>
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Name:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.name}</span>
                </div>
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Role:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.role}</span>
                </div>
                {currentValue.ref && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Ref:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.ref}</span>
                  </div>
                )}
                {currentValue.type && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Type:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.type}</span>
                  </div>
                )}
              </div>
            ) : field.tab === 'reporting_org' && typeof currentValue === 'object' ? (
              <div className="flex flex-col gap-1">
                <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                  <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">Reporting</span>
                  <span className="text-sm font-medium text-gray-900">Organization</span>
                </div>
                {currentValue.name && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Name:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.name}</span>
                  </div>
                )}
                {currentValue.acronym && (
                  <div className="flex items-center gap-1">
                    <span className="text-xs text-gray-500">Acronym:</span>
                    <span className="text-xs text-gray-600 truncate max-w-32">{currentValue.acronym}</span>
                  </div>
                )}
              </div>
            ) : typeof currentValue === 'object' && currentValue?.code ? (
              <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
              <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{currentValue.code}</span>
              <span className="text-sm font-medium text-gray-900">{currentValue.name}</span>
                {currentValue.vocabulary && (
                  <>
                    <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{currentValue.vocabulary.split(' ')[0]}</span>
                    <span className="text-xs text-gray-400 font-normal ml-1">{currentValue.vocabulary.split(' ').slice(1).join(' ')}</span>
                  </>
                )}
            </div>
          ) : (
            <span className="text-sm font-medium text-gray-900">{currentValue}</span>
          )
        ) : (
          <span className="text-sm text-gray-400 italic">Empty</span>
          );
        })()}
        </div>
      </td>
      <td className="px-4 py-3 w-40">
        <div className="space-y-1">
          {field.isPolicyMarker ? (
            <div className="flex flex-col gap-1">
              <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.code}</span>
                <span className="text-sm font-medium text-gray-900">Policy Marker</span>
              </div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-gray-500">Significance:</span>
                <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.significance}</span>
                {field.importValue.vocabulary && (
                  <>
                    <span className="text-xs text-gray-500 ml-2">Vocabulary:</span>
                    <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.vocabulary}</span>
                  </>
                )}
              </div>
              {field.importValue.rationale && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Rationale:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.rationale}</span>
                </div>
              )}
            </div>
          ) : field.tab === 'contacts' && typeof field.importValue === 'object' ? (
            <div className="flex flex-col gap-1">
              <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.type}</span>
                <span className="text-sm font-medium text-gray-900">Contact</span>
              </div>
              {field.importValue.organization && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Organization:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.organization}</span>
                </div>
              )}
              {field.importValue.personName && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Person:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.personName}</span>
                </div>
              )}
              {field.importValue.jobTitle && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Title:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.jobTitle}</span>
                </div>
              )}
              {field.importValue.email && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Email:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.email}</span>
                </div>
              )}
              {field.importValue.telephone && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Phone:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.telephone}</span>
                </div>
              )}
            </div>
          ) : field.tab === 'participating_orgs' && typeof field.importValue === 'object' ? (
            <div className="flex flex-col gap-1">
              <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.role}</span>
                <span className="text-sm font-medium text-gray-900">Participating Org</span>
              </div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-gray-500">Name:</span>
                <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.name}</span>
              </div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-gray-500">Role:</span>
                <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.role}</span>
              </div>
              {field.importValue.ref && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Ref:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.ref}</span>
                </div>
              )}
              {field.importValue.type && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Type:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.type}</span>
                </div>
              )}
            </div>
          ) : field.tab === 'reporting_org' && typeof field.importValue === 'object' ? (
            <div className="flex flex-col gap-1">
              <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">Reporting</span>
                <span className="text-sm font-medium text-gray-900">Organization</span>
              </div>
              <div className="flex items-center gap-1">
                <span className="text-xs text-gray-500">Name:</span>
                <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.name}</span>
              </div>
              {field.importValue.ref && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Ref:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.ref}</span>
                </div>
              )}
              {field.importValue.type && (
                <div className="flex items-center gap-1">
                  <span className="text-xs text-gray-500">Type:</span>
                  <span className="text-xs text-gray-600 truncate max-w-32">{field.importValue.type}</span>
                </div>
              )}
            </div>
          ) : Array.isArray(field.importValue) ? (
            field.importValue.map((item, index) => (
              <div key={index} className={`flex flex-col gap-1 ${item.locked ? 'opacity-50' : ''}`}>
                <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                  <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{item.code}</span>
                  <span className={`text-sm font-medium ${item.locked ? 'text-gray-500' : 'text-gray-900'}`}>{item.name}</span>
                  {item.percentage && (
                    <span className="text-xs text-gray-500 font-normal">({Number(item.percentage).toFixed(2)}%)</span>
                  )}
                  {item.locked && (
                    <Lock className="h-3 w-3 text-gray-500" />
                  )}
                  {item.vocabulary && (
                    <>
                      <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{item.vocabulary.split(' ')[0]}</span>
                      <span className="text-xs text-gray-400 font-normal ml-1">{item.vocabulary.split(' ').slice(1).join(' ')}</span>
                    </>
                  )}
                </div>
              </div>
            ))
          ) : typeof field.importValue === 'object' && field.importValue?.code ? (
              <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.code}</span>
                <span className="text-sm font-medium text-gray-900">{field.importValue.name}</span>
                    {field.importValue.vocabulary && (
                <>
                  <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.vocabulary.split(' ')[0]}</span>
                  <span className="text-xs text-gray-400 font-normal ml-1">{field.importValue.vocabulary.split(' ').slice(1).join(' ')}</span>
                </>
              )}
            </div>
          ) : (
            <span className="text-sm font-medium text-gray-900">{field.importValue}</span>
          )}
        </div>
      </td>
      <td className="px-4 py-3 text-left w-40">
        <div className="space-y-1 text-left">
        {field.hasConflict ? (
          <Badge variant="outline" className="text-xs border-orange-400 text-orange-700">
            <AlertCircle className="h-3 w-3 mr-1" />
            Conflict
          </Badge>
        ) : (field as any).refinedSectors ? (
          <Badge variant="outline" className="text-xs border-green-400 text-green-700">
            <CheckCircle className="h-3 w-3 mr-1" />
            Resolved
          </Badge>
        ) : (() => {
          const evaluatedCurrentValue = typeof field.currentValue === 'function' ? field.currentValue() : field.currentValue;
          return evaluatedCurrentValue;
        })() ? (
          <Badge variant="outline" className="text-xs border-green-400 text-green-700">
            <CheckCircle className="h-3 w-3 mr-1" />
            Match
          </Badge>
        ) : (
          <Badge variant="outline" className="text-xs border-blue-400 text-blue-700">
            <Info className="h-3 w-3 mr-1" />
            New
          </Badge>
        )}
          {(field as any).needsRefinement && !(field as any).refinedSectors && (
            <Badge variant="outline" className="text-xs border-yellow-400 text-yellow-700">
              <AlertCircle className="h-3 w-3 mr-1" />
              3-digit categories detected
            </Badge>
          )}
          {(field as any).hasNonDacSectors && !(field as any).refinedSectors && (
            <Badge variant="outline" className="text-xs border-red-400 text-red-700">
              <AlertCircle className="h-3 w-3 mr-1" />
              {(field as any).nonDacSectors?.length || 0} non-DAC sectors excluded
            </Badge>
          )}
        </div>
      </td>
    </tr>
  );

  // Financial sub-tabs component
  const FinancialTabContent = ({ tabSection }: { tabSection: TabSection }) => {
    const [activeFinancialTab, setActiveFinancialTab] = useState('finances');
    
    // Group financial fields by their original tab
    const financialSubTabs = {
      'finances': { name: 'Finances', fields: tabSection.fields.filter(f => f.tab === 'finances') },
      'budgets': { name: 'Budgets', fields: tabSection.fields.filter(f => f.tab === 'budgets') },
      'planned_disbursements': { name: 'Planned Disbursements', fields: tabSection.fields.filter(f => f.tab === 'planned_disbursements') },
      'transactions': { name: 'Transactions', fields: tabSection.fields.filter(f => f.tab === 'transactions') }
    };
    
    const activeSubTab = financialSubTabs[activeFinancialTab as keyof typeof financialSubTabs];
    
    return (
      <div className="space-y-4">
        {/* Financial Sub-tabs */}
        <Tabs value={activeFinancialTab} onValueChange={setActiveFinancialTab}>
          <TabsList className="grid w-full grid-cols-4">
            {Object.entries(financialSubTabs).map(([key, subTab]) => (
              <TabsTrigger key={key} value={key} className="text-sm">
                {subTab.name}
                {subTab.fields.length > 0 && (
                  <span className="ml-1 text-xs bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded-full">
                    {subTab.fields.filter(f => f.selected).length}/{subTab.fields.length}
                  </span>
                )}
              </TabsTrigger>
            ))}
          </TabsList>
          
          {Object.entries(financialSubTabs).map(([key, subTab]) => (
            <TabsContent key={key} value={key} className="mt-4">
              <RegularTabContent fields={subTab.fields} tabName={subTab.name} />
            </TabsContent>
          ))}
        </Tabs>
      </div>
    );
  };

  // Partners sub-tabs component
  const PartnersTabContent = ({ tabSection }: { tabSection: TabSection }) => {
    const [activePartnerTab, setActivePartnerTab] = useState('reporting_org');
    
    // Group partner fields by their original tab
    const partnerSubTabs = {
      'reporting_org': { name: 'Reporting Organisation', fields: tabSection.fields.filter(f => f.tab === 'reporting_org') },
      'participating_orgs': { name: 'Participating Organisations', fields: tabSection.fields.filter(f => f.tab === 'participating_orgs') }
    };
    
    // Set default active tab to the first one that has fields
    const availableTabs = Object.entries(partnerSubTabs).filter(([, subTab]) => subTab.fields.length > 0);
    const defaultTab = availableTabs.length > 0 ? availableTabs[0][0] : 'reporting_org';
    
    // Use the default tab if current active tab has no fields
    const currentActiveTab = partnerSubTabs[activePartnerTab as keyof typeof partnerSubTabs]?.fields.length > 0 
      ? activePartnerTab 
      : defaultTab;
    
    return (
      <div className="space-y-4">
        {/* Partners Sub-tabs */}
        <Tabs value={currentActiveTab} onValueChange={setActivePartnerTab}>
          <TabsList className="grid w-full grid-cols-2">
            {Object.entries(partnerSubTabs).map(([key, subTab]) => (
              <TabsTrigger key={key} value={key} className="text-sm">
                {subTab.name}
                {subTab.fields.length > 0 && (
                  <span className="ml-1 text-xs bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded-full">
                    {subTab.fields.filter(f => f.selected).length}/{subTab.fields.length}
                  </span>
                )}
              </TabsTrigger>
            ))}
          </TabsList>
          
          {Object.entries(partnerSubTabs).map(([key, subTab]) => (
            <TabsContent key={key} value={key} className="mt-4">
              <RegularTabContent fields={subTab.fields} tabName={subTab.name} />
            </TabsContent>
          ))}
        </Tabs>
      </div>
    );
  };
  
  // Regular tab content component
  const RegularTabContent = ({ fields, tabName }: { fields: ParsedField[]; tabName: string }) => {
    const tabFieldsSelected = fields.filter(f => f.selected).length;
    const tabFieldsTotal = fields.length;

    return (
      <div className="space-y-4">
        {/* Tab header with selection controls */}
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
            {/* Removed redundant badges */}
          </div>
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => {
                fields.forEach((field) => {
                  const globalIndex = parsedFields.indexOf(field);
                  toggleFieldSelection(globalIndex, true);
                });
              }}
            >
              Select All
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => {
                fields.forEach((field) => {
                  const globalIndex = parsedFields.indexOf(field);
                  toggleFieldSelection(globalIndex, false);
                });
              }}
            >
              Clear All
            </Button>
          </div>
        </div>

        {/* Table */}
        <div className="border rounded-lg overflow-hidden">
          <table className="w-full">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider text-center w-20">
                  Import
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-32">
                  Field
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-40">
                  Current Value
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-40">
                  Import Value
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-40">
                  Status
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {fields.map((field, index) => {
                const globalIndex = parsedFields.indexOf(field);
                return (
                  <FieldRow 
                    key={`${field.tab}-${index}`}
                    field={field}
                    globalIndex={globalIndex}
                  />
                );
              })}
            </tbody>
          </table>
        </div>
      </div>
    );
  };
  
  // Policy markers tab content component with Select All/Clear All functionality
  const PolicyMarkersTabContent = ({ fields, tabName }: { fields: ParsedField[]; tabName: string }) => {
    const policyMarkerFields = fields.filter(f => f.isPolicyMarker);
    const selectedCount = policyMarkerFields.filter(f => f.selected).length;
    const totalCount = policyMarkerFields.length;

    const selectAllPolicyMarkers = () => {
      const newFields = [...parsedFields];
      policyMarkerFields.forEach(policyField => {
        const index = parsedFields.findIndex(f => f === policyField);
        if (index !== -1) {
          newFields[index] = { ...newFields[index], selected: true };
        }
      });
      setParsedFields(newFields);
    };

    const clearAllPolicyMarkers = () => {
      const newFields = [...parsedFields];
      policyMarkerFields.forEach(policyField => {
        const index = parsedFields.findIndex(f => f === policyField);
        if (index !== -1) {
          newFields[index] = { ...newFields[index], selected: false };
        }
      });
      setParsedFields(newFields);
    };

    return (
      <div className="space-y-4">
        {/* Policy markers header with selection controls */}
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-4">
            <h3 className="text-lg font-medium">{tabName}</h3>
            <div className="text-sm text-gray-600">
              {selectedCount} of {totalCount} policy markers selected
            </div>
          </div>
          <div className="flex gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={clearAllPolicyMarkers}
              disabled={selectedCount === 0}
            >
              Clear All
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={selectAllPolicyMarkers}
              disabled={selectedCount === totalCount}
            >
              Select All
            </Button>
          </div>
        </div>

        {/* Policy markers table */}
        <div className="border rounded-lg overflow-hidden">
          <table className="w-full">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-12">
                  Import
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Policy Marker
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Current Value
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Import Value
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Status
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {policyMarkerFields.map((field, index) => {
                const globalIndex = parsedFields.findIndex(f => f === field);
                return (
                  <FieldRow key={globalIndex} field={field} globalIndex={globalIndex} />
                );
              })}
            </tbody>
          </table>
        </div>
      </div>
    );
  };
  
  // Main tab content component that chooses between financial, partners, and regular
  const TabFieldContent = ({ tabSection }: { tabSection: TabSection }) => {
    if (tabSection.tabId === 'finances') {
      return <FinancialTabContent tabSection={tabSection} />;
    }
    if (tabSection.tabId === 'partners') {
      return <PartnersTabContent tabSection={tabSection} />;
    }
    if (tabSection.tabId === 'policy-markers') {
      return <PolicyMarkersTabContent fields={tabSection.fields} tabName={tabSection.tabName} />;
    }
    return <RegularTabContent fields={tabSection.fields} tabName={tabSection.tabName} />;
  };

  return (
    <div className="space-y-6">
      {/* Import Method Selection and Input */}
      {importStatus.stage === 'idle' && !selectedFile && !xmlContent && (
        <div>
            {/* Method Selection */}
            <div className="mb-6">
              <Label className="text-base font-medium">Import Method</Label>
              <div className="flex gap-4 mt-2">
                <Button
                  variant={importMethod === 'file' ? 'default' : 'outline'}
                  onClick={() => {
                    setImportMethod('file');
                    setXmlUrl(''); // Clear URL when switching to file mode
                  }}
                  className="flex-1"
                >
                  <FileCode className="h-4 w-4 mr-2" />
                  Upload File
                </Button>
                <Button
                  variant={importMethod === 'url' ? 'default' : 'outline'}
                  onClick={() => {
                    setImportMethod('url');
                    setXmlUrl(''); // Clear URL when switching to URL mode to prevent duplication
                  }}
                  className="flex-1"
                >
                  <Globe className="h-4 w-4 mr-2" />
                  From URL
                </Button>
              </div>
            </div>

            {/* File Upload Section */}
            {importMethod === 'file' && (
              <div
                onDrop={handleDrop}
                onDragOver={handleDragOver}
                className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-gray-400 transition-colors cursor-pointer"
                onClick={() => document.getElementById('xml-upload')?.click()}
              >
                <FileCode className="h-12 w-12 text-gray-500 mx-auto mb-4" />
                <p className="text-gray-600 mb-2">Drop your IATI XML file here, or click to browse</p>
                <p className="text-sm text-gray-500 mb-4">Supports standard IATI Activity XML format</p>
                <input
                  type="file"
                  accept=".xml,text/xml"
                  onChange={handleFileSelect}
                  className="hidden"
                  id="xml-upload"
                />
                <Button variant="outline">
                  <FileText className="h-4 w-4 mr-2" />
                  Select XML File
                </Button>
              </div>
            )}

            {/* URL Input Section */}
            {importMethod === 'url' && (
              <div className="space-y-4">
                <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center">
                  <Link className="h-12 w-12 text-gray-500 mx-auto mb-4" />
                  <p className="text-gray-600 mb-2">Enter the URL of an IATI XML file</p>
                  <p className="text-sm text-gray-500 mb-4">Must be a publicly accessible XML document</p>
                  
                  <div className="max-w-md mx-auto space-y-3">
                    <div className="relative">
                      <Input
                        ref={urlInputRef}
                        type="url"
                        placeholder="https://example.com/iati-activity.xml"
                        value={xmlUrl}
                        onChange={(e) => {
                          console.log('[XML Import Debug] URL input onChange:', e.target.value);
                          setXmlUrl(e.target.value);
                        }}
                        onPaste={(e) => {
                          // Skip if we're using the paste button to avoid conflicts
                          if (isUsingPasteButton) {
                            return;
                          }
                          
                          // Prevent default to avoid duplication, then manually set the value
                          e.preventDefault();
                          const pastedText = e.clipboardData.getData('text');
                          console.log('[XML Import Debug] Manual paste - pasted text:', pastedText);
                          if (pastedText && pastedText.trim()) {
                            // Extract the clean URL by finding the first occurrence of the URL pattern
                            const urlPattern = /https?:\/\/[^\s]+/;
                            const match = pastedText.match(urlPattern);
                            const cleanUrl = match ? match[0] : pastedText.trim();
                            
                            console.log('[XML Import Debug] Manual paste - clean URL:', cleanUrl);
                            setXmlUrl(cleanUrl);
                          }
                        }}
                        className="text-center pr-10"
                      />
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={handlePasteUrl}
                        className="absolute right-1 top-1/2 -translate-y-1/2 h-8 w-8 p-0 hover:bg-gray-100"
                        title="Paste from clipboard"
                      >
                        <ClipboardPaste className="h-4 w-4" />
                      </Button>
                    </div>
                    <Button 
                      onClick={parseXmlFile}
                      disabled={!xmlUrl.trim()}
                      className="w-full"
                    >
                      <Globe className="h-4 w-4 mr-2" />
                      Fetch and Parse XML
                    </Button>
                  </div>
                </div>
              </div>
            )}

            <div className="mt-4">
              <div className="flex items-start gap-2">
                <Info className="h-4 w-4 mt-0.5 text-muted-foreground" />
                <div>
                  <div className="font-medium text-sm mb-2">Import Guidelines</div>
                  <ul className="list-disc list-inside space-y-1 text-sm text-muted-foreground">
                    <li>{importMethod === 'file' ? 'File' : 'URL'} must be a valid IATI Activity XML document</li>
                    {importMethod === 'url' && <li>URL must be publicly accessible (no authentication required)</li>}
                    <li>You can review all fields before importing</li>
                    <li>Existing data will be highlighted if there are conflicts</li>
                    <li>You can choose which fields to import or skip</li>
                  </ul>
                </div>
              </div>
            </div>
        </div>
      )}

      {/* XML Preview */}
      {showXmlPreview && xmlContent && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">XML Content Preview</CardTitle>
          </CardHeader>
          <CardContent>
            <pre className="bg-gray-50 p-4 rounded-lg overflow-auto max-h-64 text-xs">
              <code>{xmlContent.substring(0, 2000)}...</code>
            </pre>
          </CardContent>
        </Card>
      )}

      {/* Parsed Fields Preview - Tabbed Interface */}
      {parsedFields.length > 0 && importStatus.stage === 'previewing' && (
        <div className="space-y-6">
          {/* Overview Header */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="flex items-center gap-2">
                    <FileCode className="h-5 w-5" />
                    Review Import Fields
                  </CardTitle>
                  <CardDescription className="mt-1">
                    Fields are organized by Activity Editor tabs. Select which fields you want to import.
                  </CardDescription>
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => selectAllFields(true)}
                  >
                    Select All Fields
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => selectAllFields(false)}
                  >
                    Clear All Fields
                  </Button>
                </div>
              </div>
              
              {/* Summary Stats */}
              <div className="flex items-center gap-4 mt-4 pt-4 border-t">
                <div className="text-sm text-gray-600">
                  <strong>{parsedFields.filter(f => f.selected).length}</strong> of <strong>{parsedFields.length}</strong> fields selected
                </div>
                {parsedFields.filter(f => f.selected && f.hasConflict).length > 0 && (
                  <div className="text-sm text-orange-700">
                    <AlertCircle className="h-4 w-4 inline mr-1" />
                    <strong>{parsedFields.filter(f => f.selected && f.hasConflict).length}</strong> conflicts to resolve
                  </div>
                )}
              </div>
            </CardHeader>
          </Card>

          {/* Tabbed Field Interface */}
          <Card>
            <CardContent className="pt-6">
              <Tabs value={activeImportTab} onValueChange={setActiveImportTab}>
                <TabsList className="grid w-full grid-cols-7">
                  {organizeFieldsByTabs(parsedFields).map((tabSection) => {
                    const selectedCount = tabSection.fields.filter(f => f.selected).length;
                    const totalCount = tabSection.fields.length;
                    const hasConflicts = tabSection.fields.some(f => f.hasConflict && f.selected);
                    
                    return (
                      <TabsTrigger 
                        key={tabSection.tabId} 
                        value={tabSection.tabId}
                        className="relative"
                      >
                        <span className="text-xs font-medium">{tabSection.tabName}</span>
                        {hasConflicts && (
                          <AlertCircle className="h-3 w-3 text-orange-500 ml-1" />
                        )}
                      </TabsTrigger>
                    );
                  })}
                </TabsList>

                {/* Tab Contents */}
                {organizeFieldsByTabs(parsedFields).map((tabSection) => (
                  <TabsContent key={tabSection.tabId} value={tabSection.tabId} className="mt-6">
                    <TabFieldContent tabSection={tabSection} />
                  </TabsContent>
                ))}
              </Tabs>
            </CardContent>
          </Card>

          {/* Import Actions */}
          <div className="flex justify-end gap-2 pt-6">
            <Button variant="outline" onClick={resetImport}>
              Cancel Import
            </Button>
            <Button 
              onClick={() => {
                console.log('[XML Import] Button clicked!');
                importSelectedFields();
              }}
              disabled={parsedFields.filter(f => f.selected).length === 0}
              className="bg-blue-600 hover:bg-blue-700"
            >
              <Database className="h-4 w-4 mr-2" />
              Import Selected Fields
            </Button>
          </div>
        </div>
      )}

      {/* Import Complete */}
      {importStatus.stage === 'complete' && (
        <Card>
          <CardContent className="pt-6">
            <div className="text-center py-8">
              <CheckCircle className="h-16 w-16 text-gray-700 mx-auto mb-4" />
              <h3 className="text-lg font-medium mb-2">Import Successful!</h3>
              <p className="text-gray-600 mb-6">
                {parsedFields.filter(f => f.selected).length} fields have been imported from the XML file.
              </p>
              <div className="flex gap-2 justify-center">
                <Button variant="outline" onClick={resetImport}>
                  <FileCode className="h-4 w-4 mr-2" />
                  Import Another File
                </Button>
                <Button onClick={() => {
                  // Navigate to Basic Info tab to review imported changes
                  const basicTab = document.querySelector('[data-value="basic"]') as HTMLButtonElement;
                  if (basicTab) {
                    basicTab.click();
                  }
                  // Also scroll to top to show the imported data
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                }}>
                  <ArrowRight className="h-4 w-4 mr-2" />
                  Review Changes
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Error State */}
      {importStatus.stage === 'error' && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <div className="font-medium">Import Error</div>
          <AlertDescription>
            {importStatus.message || 'An error occurred during import. Please try again.'}
          </AlertDescription>
        </Alert>
      )}

      {/* Sector Refinement Modal */}
      <SectorRefinementModal
        isOpen={showSectorRefinement}
        onClose={() => setShowSectorRefinement(false)}
        originalSectors={sectorRefinementData.originalSectors}
        onSave={(refinedSectors) => {
          console.log('[Sector Refinement] Saving refined sectors:', refinedSectors);
          console.log('[Sector Refinement] Refined sectors count:', refinedSectors.length);
          console.log('[Sector Refinement] Refined sectors details:', refinedSectors.map(s => ({
            code: s.code,
            name: s.name,
            percentage: s.percentage,
            originalCode: s.originalCode,
            isValid: /^\d{5}$/.test(s.code)
          })));
          
          const totalPercentage = refinedSectors.reduce((sum, s) => sum + (s.percentage || 0), 0);
          console.log('[Sector Refinement] Total percentage:', totalPercentage);
          
          // Store the refined sectors for later import
          setSavedRefinedSectors(refinedSectors);
          
          // Update the parsed fields with refined sectors display
          const updatedFields = parsedFields.map(field => {
            if (field.fieldName === 'Sectors') {
              const refinedSectorInfo = refinedSectors.map(s => ({
                code: s.code,
                name: s.name,
                percentage: s.percentage
              }));
              
              return {
                ...field,
                importValue: refinedSectorInfo,
                description: 'Sector classifications and allocations - Refined successfully',
                hasConflict: false, // Conflict resolved after refinement
                refinedSectors: refinedSectors // Store refined sectors in field for import
              };
            }
            return field;
          });
          
          setParsedFields(updatedFields);
          setSectorRefinementData({ originalSectors: [], refinedSectors: [] });
          setShowSectorRefinement(false);
          toast.success('Sectors refined successfully - ready for import');
        }}
      />
      
      {/* External Publisher Modal */}
      {externalPublisherMeta && (
        <ExternalPublisherModal
          isOpen={showExternalPublisherModal}
          onClose={() => {
            setShowExternalPublisherModal(false);
            setExternalPublisherMeta(null);
            // Reset the import state if user cancels
            resetImport();
          }}
          meta={externalPublisherMeta}
          userOrgName={userOrgName}
          userPublisherRefs={userPublisherRefs}
          currentActivityId={activityId}
          currentActivityIatiId={currentActivityData.iati_identifier}
          existingActivity={existingActivity}
          onChoose={async (choice, targetActivityId) => {
            console.log('[XML Import] External publisher choice:', choice, targetActivityId);
            
            // Check if user is authenticated
            if (!user?.id) {
              toast.error('You must be logged in to import XML activities');
              return;
            }
            
            try {
              let response;
              
              switch (choice) {
                case 'reference':
                  // Create read-only reference
                  toast.info('Creating read-only reference...');
                  response = await fetch('/api/iati/reference', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      meta: externalPublisherMeta,
                      userId: user.id
                    })
                  });
                  
                  if (response.ok) {
                    const data = await response.json();
                    toast.success('Linked as reference', {
                      description: 'Read-only activity created. It will not count towards your totals.'
                    });
                    setShowExternalPublisherModal(false);
                    // Redirect to the new activity
                    window.location.href = `/activities/${data.id}`;
                  }
                  break;
                  
                case 'fork':
                  // Create editable copy
                  toast.info('Creating local draft copy...');
                  response = await fetch('/api/iati/fork', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      meta: externalPublisherMeta,
                      userId: user.id
                    })
                  });
                  
                  if (response.ok) {
                    const data = await response.json();
                    toast.success('Fork created', {
                      description: 'You can now edit this activity. Remember to assign your own IATI ID before publishing.'
                    });
                    setShowExternalPublisherModal(false);
                    // Continue with the field comparison that was already parsed
                    // The parsed fields are already set, just update the status
                    setImportStatus({ stage: 'previewing', progress: 100 });
                  }
                  break;
                  
                case 'merge':
                  // Link to existing activity
                  if (targetActivityId) {
                    toast.info('Linking to existing activity...');
                    response = await fetch('/api/iati/merge', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({
                        meta: externalPublisherMeta,
                        targetActivityId,
                        userId: user.id
                      })
                    });
                    
                    if (response.ok) {
                      toast.success('Linked successfully', {
                        description: 'External record linked to your existing activity.'
                      });
                      setShowExternalPublisherModal(false);
                      // Continue with the field comparison that was already parsed
                      // The parsed fields are already set, just update the status
                      setImportStatus({ stage: 'previewing', progress: 100 });
                    }
                  }
                  break;
              }
              
              if (response && !response.ok) {
                const error = await response.json();
                toast.error(`Operation failed: ${error.error || error.message}`);
              }
            } catch (error) {
              console.error('[XML Import] Error handling external publisher choice:', error);
              toast.error('Operation failed', {
                description: error instanceof Error ? error.message : 'Unknown error'
              });
            }
          }}
        />
      )}

      {/* Financial Item Detail Modal */}
      {showDetailModal && selectedItem && (
        <Dialog open={showDetailModal} onOpenChange={setShowDetailModal}>
          <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle className="flex items-center gap-2">
                <Eye className="h-5 w-5" />
                Select Fields for {selectedItem.type.charAt(0).toUpperCase() + selectedItem.type.slice(1)} {selectedItem.index + 1}
              </DialogTitle>
              <DialogDescription>
                Choose which specific fields from this {selectedItem.type} to import into your activity.
              </DialogDescription>
            </DialogHeader>

            <div className="space-y-4">
              <div className="bg-gray-50 p-3 rounded-lg">
                <h4 className="font-medium text-gray-700 mb-2">Item Summary:</h4>
                <div className="text-sm text-gray-600">
                  {selectedItem.type === 'budget' && selectedItem.data && (
                    <div className="space-y-1">
                      {selectedItem.data.type && <div><strong>Type:</strong> {selectedItem.data.type}</div>}
                      {selectedItem.data.status && <div><strong>Status:</strong> {selectedItem.data.status}</div>}
                      {selectedItem.data.period?.start && <div><strong>Start Date:</strong> {selectedItem.data.period.start}</div>}
                      {selectedItem.data.period?.end && <div><strong>End Date:</strong> {selectedItem.data.period.end}</div>}
                      {selectedItem.data.value && <div><strong>Amount:</strong> {selectedItem.data.value.toLocaleString()} {selectedItem.data.currency}</div>}
                    </div>
                  )}
                  {selectedItem.type === 'transaction' && selectedItem.data && (
                    <div className="space-y-1">
                      {selectedItem.data.type && (
                        <div><strong>Type:</strong> {(() => {
                          const transactionTypes: Record<string, string> = {
                            '1': 'Incoming Funds',
                            '2': 'Commitment',
                            '3': 'Disbursement',
                            '4': 'Expenditure',
                            '5': 'Interest Repayment',
                            '6': 'Loan Repayment',
                            '7': 'Reimbursement',
                            '8': 'Purchase of Equity',
                            '9': 'Sale of Equity',
                            '10': 'Credit Guarantee',
                            '11': 'Incoming Commitment',
                            '12': 'Outgoing Pledge',
                            '13': 'Incoming Pledge'
                          };
                          return transactionTypes[selectedItem.data.type] || selectedItem.data.type;
                        })()}</div>
                      )}
                      {selectedItem.data.date && <div><strong>Date:</strong> {selectedItem.data.date}</div>}
                      {selectedItem.data.value && <div><strong>Amount:</strong> {selectedItem.data.value.toLocaleString()} {selectedItem.data.currency || ''}</div>}
                      {selectedItem.data.description && <div><strong>Description:</strong> {selectedItem.data.description}</div>}
                      {selectedItem.data.providerOrg?.name && <div><strong>Provider:</strong> {selectedItem.data.providerOrg.name}</div>}
                      {selectedItem.data.receiverOrg?.name && <div><strong>Receiver:</strong> {selectedItem.data.receiverOrg.name}</div>}
                      {selectedItem.data.humanitarian && <div><strong>Humanitarian:</strong> Yes</div>}
                      {selectedItem.data.flowType && <div><strong>Flow Type:</strong> {selectedItem.data.flowType}</div>}
                      {selectedItem.data.financeType && <div><strong>Finance Type:</strong> {selectedItem.data.financeType}</div>}
                      {selectedItem.data.aidType && <div><strong>Aid Type:</strong> {selectedItem.data.aidType.code || selectedItem.data.aidType}</div>}
                      {selectedItem.data.tiedStatus && <div><strong>Tied Status:</strong> {selectedItem.data.tiedStatus}</div>}
                    </div>
                  )}
                  {selectedItem.type === 'plannedDisbursement' && selectedItem.data && (
                    <div className="space-y-1">
                      {selectedItem.data.type && <div><strong>Type:</strong> {selectedItem.data.type}</div>}
                      {selectedItem.data.periodStart && <div><strong>Period Start:</strong> {selectedItem.data.periodStart}</div>}
                      {selectedItem.data.periodEnd && <div><strong>Period End:</strong> {selectedItem.data.periodEnd}</div>}
                      {selectedItem.data.value && <div><strong>Amount:</strong> {selectedItem.data.value.toLocaleString()} {selectedItem.data.currency}</div>}
                    </div>
                  )}
                </div>
              </div>

              {/* Field Selection Table */}
              <div className="border rounded-lg overflow-hidden">
                <table className="w-full">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="text-left px-4 py-2 font-medium text-gray-700 w-12">Import</th>
                      <th className="text-left px-4 py-2 font-medium text-gray-700">Field</th>
                      <th className="text-left px-4 py-2 font-medium text-gray-700">Value</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200">
                    {selectedItem.fields.map((field, index) => (
                      <tr key={index} className="bg-white hover:bg-gray-50">
                        <td className="px-4 py-3 text-center">
                          <Switch
                            checked={field.selected}
                            onCheckedChange={(checked) => {
                              const updatedFields = [...selectedItem.fields];
                              updatedFields[index].selected = checked;
                              setSelectedItem({
                                ...selectedItem,
                                fields: updatedFields
                              });
                            }}
                          />
                        </td>
                        <td className="px-4 py-3">
                          <p className="font-medium text-sm text-gray-900">{field.fieldName}</p>
                        </td>
                        <td className="px-4 py-3">
                          <div className="space-y-1">
                            {typeof field.importValue === 'object' && field.importValue?.code ? (
                              <div className="flex items-center gap-1 flex-nowrap whitespace-nowrap">
                                <span className="text-xs font-mono text-muted-foreground bg-muted px-1.5 py-0.5 rounded">{field.importValue.code}</span>
                                <span className="text-sm font-medium text-gray-900">{field.importValue.name}</span>
                              </div>
                            ) : (
                              <span className="text-sm font-medium text-gray-900">{field.importValue || 'N/A'}</span>
                            )}
                          </div>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>

            <DialogFooter>
              <Button variant="outline" onClick={() => setShowDetailModal(false)}>
                Cancel
              </Button>
              <Button onClick={() => {
                // Update the main fields with the selected detail fields
                const updatedFields = [...parsedFields];
                const mainFieldIndex = updatedFields.findIndex(f => 
                  f.isFinancialItem && 
                  f.itemType === selectedItem.type && 
                  f.itemIndex === selectedItem.index
                );
                
                if (mainFieldIndex !== -1) {
                  // Update the summary to show selection status
                  const selectedCount = selectedItem.fields.filter(f => f.selected).length;
                  const totalCount = selectedItem.fields.length;
                  updatedFields[mainFieldIndex].importValue = `${selectedCount} of ${totalCount} fields selected`;
                }
                
                setParsedFields(updatedFields);
                setShowDetailModal(false);
              }}>
                Apply Selection
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}

      {/* Debug Console Modal */}
      <Dialog open={showDebugConsole} onOpenChange={setShowDebugConsole}>
        <DialogContent className="max-w-4xl max-h-[80vh]">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <Bug className="h-5 w-5" />
              Debug Console
              <Badge variant="secondary" className="ml-2">
                {debugLogs.length} logs
              </Badge>
            </DialogTitle>
            <DialogDescription>
              Console logs captured during XML import process. Use this to debug import issues.
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={copyDebugLogs}
                className="flex items-center gap-2"
              >
                <Copy className="h-4 w-4" />
                Copy All Logs
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={clearDebugLogs}
                className="flex items-center gap-2 text-red-600 hover:text-red-700"
              >
                <X className="h-4 w-4" />
                Clear Logs
              </Button>
            </div>
            
            <div className="bg-black text-green-400 p-4 rounded-lg font-mono text-sm max-h-96 overflow-y-auto">
              {debugLogs.length === 0 ? (
                <div className="text-gray-500">No debug logs captured yet. Try importing an XML file to see logs here.</div>
              ) : (
                debugLogs.map((log, index) => (
                  <div key={index} className="whitespace-pre-wrap break-words">
                    {log}
                  </div>
                ))
              )}
            </div>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDebugConsole(false)}>
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

    </div>
  );
}

// Sector Refinement Modal Component
interface PortalDropdownProps {
  sector: any;
  sectorsGroup: any[];
  originalIndex: number;
  isOpen: boolean;
  onToggle: () => void;
  onSelect: (code: string) => void;
}

const PortalDropdown = ({ sector, sectorsGroup, originalIndex, isOpen, onToggle, onSelect }: PortalDropdownProps) => {
  const [buttonRect, setButtonRect] = useState<DOMRect | null>(null);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen && buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect();
      setButtonRect(rect);
    }
  }, [isOpen]);

  // Handle click outside to close dropdown
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isOpen && 
          buttonRef.current && 
          !buttonRef.current.contains(event.target as Node) &&
          dropdownRef.current && 
          !dropdownRef.current.contains(event.target as Node)) {
        onToggle();
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen, onToggle]);

  const filteredSubsectors = sector.availableSubsectors.filter((subsector: any) => {
    const usedCodes = sectorsGroup.map((s: any) => s.code);
    return !usedCodes.includes(subsector.code) || sector.code === subsector.code;
  });

  const dropdownContent = isOpen && buttonRect && (
    <div 
      ref={dropdownRef}
      className="fixed bg-white border border-gray-200 rounded-md shadow-lg z-[9999] max-h-[200px] overflow-y-auto"
      style={{
        top: buttonRect.bottom + 4,
        left: buttonRect.left,
        width: buttonRect.width,
      }}
    >
      {filteredSubsectors.map((subsector: any) => (
        <div
          key={subsector.code}
          onClick={() => onSelect(subsector.code)}
          className="flex items-center gap-2 px-3 py-2 text-sm cursor-pointer hover:bg-accent border-b border-gray-100 last:border-b-0 whitespace-nowrap"
        >
          <span className="text-xs font-mono text-gray-600 bg-gray-100 px-1.5 py-0.5 rounded min-w-[50px]">
            {subsector.code}
          </span>
          <span className="font-medium text-gray-900 flex-1 truncate">
            {subsector.name}
          </span>
          {sector.code === subsector.code && (
            <Check className="h-4 w-4 text-blue-600 flex-shrink-0" />
          )}
        </div>
      ))}
    </div>
  );

  return (
    <div className="relative">
      <Button
        ref={buttonRef}
        variant="outline"
        role="combobox"
        onClick={onToggle}
        className="flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 hover:bg-accent/50 transition-colors"
      >
        <span className="truncate">
          <span className="flex items-center gap-2">
            <span className="text-xs font-mono text-gray-600 bg-gray-100 px-1.5 py-0.5 rounded">{sector.code}</span>
            <span className="font-medium text-gray-900">{sector.name}</span>
          </span>
        </span>
        <ChevronsUpDown className="h-4 w-4 shrink-0 opacity-50" />
      </Button>
      
      {dropdownContent && createPortal(dropdownContent, document.body)}
    </div>
  );
};

interface SectorRefinementModalProps {
  isOpen: boolean;
  onClose: () => void;
  originalSectors: any[];
  onSave: (refinedSectors: any[]) => void;
}

const SectorRefinementModal = ({ isOpen, onClose, originalSectors, onSave }: SectorRefinementModalProps) => {
  const [refinedSectors, setRefinedSectors] = useState<any[]>([]);
  const [totalPercentage, setTotalPercentage] = useState(0);
  const [openPopoverId, setOpenPopoverId] = useState<string | null>(null);
  
  // Separate DAC and non-DAC sectors
  const dacSectors = refinedSectors.filter(sector => sector.isValid && /^\d{5}$/.test(sector.code));
  const nonDacSectors = refinedSectors.filter(sector => !sector.isValid || !/^\d{5}$/.test(sector.code));
  
  // Calculate total percentage only for DAC sectors
  const dacTotalPercentage = dacSectors.reduce((sum, s) => sum + (s.percentage || 0), 0);

  // IATI DAC sector reference data - comprehensive mapping
  const getSubsectorsFor3DigitCode = (threeDigitCode: string) => {
    const subsectorMap: Record<string, any[]> = {
      // SOCIAL INFRASTRUCTURE & SERVICES
      '111': [ // Education, Level Unspecified
        { code: '11110', name: 'Education policy and administrative management' },
        { code: '11120', name: 'Education facilities and training' },
        { code: '11130', name: 'Teacher training' },
        { code: '11182', name: 'Educational research' }
      ],
      '112': [ // Basic Education
        { code: '11220', name: 'Primary education' },
        { code: '11230', name: 'Basic life skills for adults' },
        { code: '11240', name: 'Early childhood education' }
      ],
      '113': [ // Secondary Education
        { code: '11320', name: 'Secondary education' },
        { code: '11330', name: 'Vocational training' }
      ],
      '114': [ // Post-Secondary Education
        { code: '11420', name: 'Higher education' },
        { code: '11430', name: 'Advanced technical and managerial training' }
      ],
      '121': [ // Health, General
        { code: '12110', name: 'Health policy and administrative management' },
        { code: '12181', name: 'Medical education/training' },
        { code: '12182', name: 'Medical research' },
        { code: '12191', name: 'Medical services' }
      ],
      '122': [ // Basic Health
        { code: '12220', name: 'Basic health care' },
        { code: '12230', name: 'Basic health infrastructure' },
        { code: '12240', name: 'Basic nutrition' },
        { code: '12250', name: 'Infectious disease control' },
        { code: '12261', name: 'Health education' },
        { code: '12281', name: 'Health personnel development' }
      ],
      '130': [ // Population Policies/Programmes & Reproductive Health
        { code: '13010', name: 'Population policy and administrative management' },
        { code: '13020', name: 'Reproductive health care' },
        { code: '13030', name: 'Family planning' },
        { code: '13040', name: 'STD control including HIV/AIDS' },
        { code: '13081', name: 'Personnel development for population and reproductive health' }
      ],
      '140': [ // Water Supply & Sanitation
        { code: '14010', name: 'Water sector policy and administrative management' },
        { code: '14015', name: 'Water resources conservation (including data collection)' },
        { code: '14020', name: 'Water supply and sanitation - large systems' },
        { code: '14030', name: 'Basic drinking water supply and basic sanitation' },
        { code: '14040', name: 'River development' },
        { code: '14050', name: 'Waste management/disposal' },
        { code: '14081', name: 'Education and training in water supply and sanitation' }
      ],
      '151': [ // Government & Civil Society-general
        { code: '15110', name: 'Public sector policy and administrative management' },
        { code: '15111', name: 'Public finance management (PFM)' },
        { code: '15112', name: 'Decentralisation and support to subnational government' },
        { code: '15113', name: 'Anti-corruption organisations and institutions' },
        { code: '15130', name: 'Legal and judicial development' },
        { code: '15150', name: 'Democratic participation and civil society' },
        { code: '15160', name: 'Human rights' },
        { code: '15170', name: "Women's rights organisations and movements" },
        { code: '15180', name: 'Ending violence against women and girls' }
      ],
      '152': [ // Conflict, Peace & Security
        { code: '15210', name: 'Security system management and reform' },
        { code: '15220', name: 'Civilian peace-building, conflict prevention and resolution' },
        { code: '15230', name: 'Participation in international peacekeeping operations' },
        { code: '15240', name: 'Reintegration and SALW control' },
        { code: '15250', name: 'Removal of land mines and explosive remnants of war' },
        { code: '15261', name: 'Child soldiers (prevention and demobilisation)' }
      ],
      '160': [ // Other Social Infrastructure & Services
        { code: '16010', name: 'Social Protection' },
        { code: '16020', name: 'Employment creation' },
        { code: '16030', name: 'Housing policy and administrative management' },
        { code: '16040', name: 'Low-cost housing' },
        { code: '16050', name: 'Multisector aid for basic social services' },
        { code: '16061', name: 'Culture and recreation' },
        { code: '16062', name: 'Statistical capacity building' },
        { code: '16063', name: 'Narcotics control' },
        { code: '16064', name: 'Social mitigation of HIV/AIDS' }
      ],
      
      // ECONOMIC INFRASTRUCTURE & SERVICES
      '210': [ // Transport & Storage
        { code: '21010', name: 'Transport policy and administrative management' },
        { code: '21020', name: 'Road transport' },
        { code: '21030', name: 'Rail transport' },
        { code: '21040', name: 'Water transport' },
        { code: '21050', name: 'Air transport' },
        { code: '21061', name: 'Storage' },
        { code: '21081', name: 'Education and training in transport and storage' }
      ],
      '220': [ // Communications
        { code: '22010', name: 'Communications policy and administrative management' },
        { code: '22020', name: 'Telecommunications' },
        { code: '22030', name: 'Radio/television/print media' },
        { code: '22040', name: 'Information and communication technology (ICT)' }
      ],
      '230': [ // Energy
        { code: '23010', name: 'Energy policy and administrative management' },
        { code: '23020', name: 'Power generation/non-renewable sources' },
        { code: '23030', name: 'Power generation/renewable sources' },
        { code: '23040', name: 'Electrical transmission/ distribution' },
        { code: '23050', name: 'Gas distribution' },
        { code: '23061', name: 'Oil-fired power plants' },
        { code: '23062', name: 'Gas-fired power plants' },
        { code: '23063', name: 'Coal-fired power plants' },
        { code: '23064', name: 'Nuclear power plants' },
        { code: '23065', name: 'Hydro-electric power plants' },
        { code: '23066', name: 'Geothermal energy' },
        { code: '23067', name: 'Solar energy' },
        { code: '23068', name: 'Wind power' },
        { code: '23069', name: 'Ocean power' },
        { code: '23070', name: 'Biomass' },
        { code: '23081', name: 'Energy education/training' },
        { code: '23082', name: 'Energy research' }
      ],
      '240': [ // Banking & Financial Services
        { code: '24010', name: 'Financial policy and administrative management' },
        { code: '24020', name: 'Monetary institutions' },
        { code: '24030', name: 'Formal sector financial intermediaries' },
        { code: '24040', name: 'Informal/semi-formal financial intermediaries' },
        { code: '24050', name: 'Remittance facilitation, promotion and optimisation' },
        { code: '24081', name: 'Education/training in banking and financial services' }
      ],
      '250': [ // Business & Other Services
        { code: '25010', name: 'Business support services and institutions' },
        { code: '25020', name: 'Privatisation' },
        { code: '25030', name: 'Business development services' },
        { code: '25040', name: 'Responsible business conduct' }
      ],
      
      // PRODUCTION SECTORS
      '311': [ // Agriculture
        { code: '31110', name: 'Agricultural policy and administrative management' },
        { code: '31120', name: 'Agricultural development' },
        { code: '31130', name: 'Agricultural land resources' },
        { code: '31140', name: 'Agricultural water resources' },
        { code: '31150', name: 'Agricultural inputs' },
        { code: '31161', name: 'Food crop production' },
        { code: '31162', name: 'Industrial crops/export crops' },
        { code: '31163', name: 'Livestock' },
        { code: '31164', name: 'Agrarian reform' },
        { code: '31165', name: 'Agricultural alternative development' },
        { code: '31166', name: 'Agricultural extension' },
        { code: '31181', name: 'Agricultural education/training' },
        { code: '31182', name: 'Agricultural research' },
        { code: '31191', name: 'Agricultural services' },
        { code: '31192', name: 'Plant and post-harvest protection and pest control' },
        { code: '31193', name: 'Agricultural financial services' },
        { code: '31194', name: 'Agricultural co-operatives' },
        { code: '31195', name: 'Livestock/veterinary services' }
      ],
      '312': [ // Forestry
        { code: '31210', name: 'Forestry policy and administrative management' },
        { code: '31220', name: 'Forestry development' },
        { code: '31261', name: 'Fuelwood/charcoal' },
        { code: '31281', name: 'Forestry education/training' },
        { code: '31282', name: 'Forestry research' },
        { code: '31291', name: 'Forestry services' }
      ],
      '313': [ // Fishing
        { code: '31310', name: 'Fishing policy and administrative management' },
        { code: '31320', name: 'Fishery development' },
        { code: '31381', name: 'Fishery education/training' },
        { code: '31382', name: 'Fishery research' },
        { code: '31391', name: 'Fishery services' }
      ],
      '321': [ // Industry
        { code: '32110', name: 'Industrial policy and administrative management' },
        { code: '32120', name: 'Industrial development' },
        { code: '32130', name: 'Small and medium-sized enterprises (SME) development' },
        { code: '32140', name: 'Cottage industries and handicraft' },
        { code: '32161', name: 'Agro-industries' },
        { code: '32162', name: 'Forest industries' },
        { code: '32163', name: 'Textiles, leather and substitutes' },
        { code: '32164', name: 'Chemicals' },
        { code: '32165', name: 'Fertilizer plants' },
        { code: '32166', name: 'Cement/lime/plaster' },
        { code: '32167', name: 'Energy manufacturing' },
        { code: '32168', name: 'Pharmaceutical production' },
        { code: '32169', name: 'Basic metal industries' },
        { code: '32170', name: 'Non-ferrous metal industries' },
        { code: '32171', name: 'Engineering' },
        { code: '32172', name: 'Transport equipment industry' },
        { code: '32182', name: 'Technological research and development' }
      ],
      '322': [ // Mineral Resources & Mining
        { code: '32210', name: 'Mineral/mining policy and administrative management' },
        { code: '32220', name: 'Mineral prospection and exploration' },
        { code: '32261', name: 'Coal' },
        { code: '32262', name: 'Oil and gas (upstream)' },
        { code: '32263', name: 'Ferrous metals' },
        { code: '32264', name: 'Nonferrous metals' },
        { code: '32265', name: 'Precious metals/materials' },
        { code: '32266', name: 'Industrial minerals' },
        { code: '32267', name: 'Fertilizer minerals' },
        { code: '32268', name: 'Offshore minerals' }
      ],
      '323': [ // Construction
        { code: '32310', name: 'Construction policy and administrative management' }
      ],
      '331': [ // Trade Policies & Regulations
        { code: '33110', name: 'Trade policy and administrative management' },
        { code: '33120', name: 'Trade facilitation' },
        { code: '33130', name: 'Regional trade agreements (RTAs)' },
        { code: '33140', name: 'Multilateral trade negotiations' },
        { code: '33150', name: 'Trade-related adjustment' },
        { code: '33181', name: 'Trade education/training' }
      ],
      '332': [ // Tourism
        { code: '33210', name: 'Tourism policy and administrative management' }
      ],
      
      // MULTI-SECTOR / CROSS-CUTTING
      '410': [ // General Environment Protection
        { code: '41010', name: 'Environmental policy and administrative management' },
        { code: '41020', name: 'Biosphere protection' },
        { code: '41030', name: 'Bio-diversity' },
        { code: '41040', name: 'Site preservation' },
        { code: '41050', name: 'Flood prevention/control' },
        { code: '41081', name: 'Environmental education/training' },
        { code: '41082', name: 'Environmental research' }
      ],
      '430': [ // Other Multisector
        { code: '43010', name: 'Multisector aid' },
        { code: '43030', name: 'Urban development and management' },
        { code: '43040', name: 'Rural development' },
        { code: '43050', name: 'Non-agricultural alternative development' },
        { code: '43081', name: 'Multisector education/training' },
        { code: '43082', name: 'Research/scientific institutions' }
      ],
      
      // COMMODITY AID / GENERAL PROGRAMME ASSISTANCE
      '520': [ // Development Food Assistance
        { code: '52010', name: 'Food assistance' }
      ],
      '530': [ // Other Commodity Assistance
        { code: '53030', name: 'Import support (capital goods)' },
        { code: '53040', name: 'Import support (commodities)' }
      ],
      
      // ACTION RELATING TO DEBT
      '600': [ // Action Relating to Debt
        { code: '60010', name: 'Action relating to debt' },
        { code: '60020', name: 'Debt forgiveness' },
        { code: '60030', name: 'Relief of multilateral debt' },
        { code: '60040', name: 'Rescheduling and refinancing' },
        { code: '60061', name: 'Debt for development swap' },
        { code: '60062', name: 'Other debt swap' },
        { code: '60063', name: 'Debt buy-back' }
      ],
      
      // HUMANITARIAN AID
      '720': [ // Emergency Response
        { code: '72010', name: 'Material relief assistance and services' },
        { code: '72040', name: 'Emergency food assistance' },
        { code: '72050', name: 'Relief co-ordination and support services' }
      ],
      '730': [ // Reconstruction Relief & Rehabilitation
        { code: '73010', name: 'Reconstruction relief and rehabilitation' }
      ],
      '740': [ // Disaster Prevention & Preparedness
        { code: '74010', name: 'Disaster prevention and preparedness' },
        { code: '74020', name: 'Multi-hazard response preparedness' }
      ],
      
      // UNALLOCATED / UNSPECIFIED
      '998': [ // Unallocated / Unspecified
        { code: '99810', name: 'Sectors not specified' },
        { code: '99820', name: 'Promotion of development awareness' }
      ]
    };
    
    // Return the subsectors for the given code, or create generic ones if not found
    if (subsectorMap[threeDigitCode]) {
      return subsectorMap[threeDigitCode];
    }
    
    // Create generic subsectors for unknown codes
    return [
      { code: `${threeDigitCode}10`, name: `${threeDigitCode} - Policy and administrative management` },
      { code: `${threeDigitCode}20`, name: `${threeDigitCode} - Development and implementation` },
      { code: `${threeDigitCode}30`, name: `${threeDigitCode} - Education and training` },
      { code: `${threeDigitCode}40`, name: `${threeDigitCode} - Research and development` }
    ];
  };

  // Sector validation functions
  const isValidSectorCode = (code: string): boolean => {
    if (!code) return false;
    // 3-digit codes should be numeric
    if (code.length === 3) return /^\d{3}$/.test(code);
    // 5-digit codes should be numeric
    if (code.length === 5) return /^\d{5}$/.test(code);
    return false;
  };

  const normalizePercentages = (sectors: any[]): any[] => {
    const totalPercentage = sectors.reduce((sum, s) => sum + (s.percentage || 0), 0);
    
    if (totalPercentage === 0) {
      // Equal distribution if no percentages provided
      const equalPercentage = Math.round((100 / sectors.length) * 100) / 100;
      return sectors.map(s => ({ ...s, percentage: equalPercentage }));
    }
    
    if (Math.abs(totalPercentage - 100) > 0.01) {
      // Normalize to 100%
      const factor = 100 / totalPercentage;
      return sectors.map(s => ({
        ...s,
        percentage: Math.round((s.percentage || 0) * factor * 100) / 100
      }));
    }
    
    return sectors;
  };

  const detectSectorIssues = (sectors: any[]): string[] => {
    const issues: string[] = [];
    
    // Only check percentage total for DAC sectors
    const dacSectors = sectors.filter(s => s.isValid && /^\d{5}$/.test(s.code));
    const total = dacSectors.reduce((sum, s) => sum + (s.percentage || 0), 0);
    if (Math.abs(total - 100) > 0.01) {
      issues.push(`Sector percentages total ${total.toFixed(1)}% instead of 100%`);
    }
    
    // Check for zero percentages in DAC sectors only
    const zeroPercentages = dacSectors.filter(s => (s.percentage || 0) === 0);
    if (zeroPercentages.length > 0 && dacSectors.length > 1) {
      issues.push(`${zeroPercentages.length} sector(s) have 0% allocation`);
    }
    
    return issues;
  };

  useEffect(() => {
    if (isOpen && originalSectors.length > 0) {
      console.log('[SectorRefinement] Initializing with original sectors:', originalSectors);
      
      // Process original sectors with validation
      const processedSectors = originalSectors.map(sector => {
        console.log('[SectorRefinement] Processing sector:', sector);
        
        if (!isValidSectorCode(sector.code)) {
          console.warn('[SectorRefinement] Invalid sector code detected:', sector.code);
        }
        
        if (sector.code && sector.code.length === 3) {
          const subsectors = getSubsectorsFor3DigitCode(sector.code);
          console.log('[SectorRefinement] Found', subsectors.length, 'subsectors for code:', sector.code);
          
          // Default to first subsector for this category
          return {
            originalCode: sector.code,
            originalPercentage: sector.percentage || 0,
            code: subsectors[0]?.code || `${sector.code}10`,
            name: subsectors[0]?.name || `${sector.code} - Default subsector`,
            percentage: sector.percentage || 0,
            availableSubsectors: subsectors,
            needsRefinement: true,
            isValid: isValidSectorCode(sector.code),
            id: crypto.randomUUID() // Add unique ID for React keys
          };
        }
        
        // If already 5-digit or other format, keep as is but validate
        return {
          originalCode: sector.code,
          originalPercentage: sector.percentage || 0,
          code: sector.code,
          name: sector.narrative || sector.name || `Unknown sector ${sector.code}`,
          percentage: sector.percentage || 0,
          availableSubsectors: [],
          needsRefinement: false,
          isValid: isValidSectorCode(sector.code),
          id: crypto.randomUUID() // Add unique ID for React keys
        };
      });
      
      // Normalize percentages if needed
      const normalizedSectors = normalizePercentages(processedSectors);
      console.log('[SectorRefinement] Normalized sectors:', normalizedSectors);
      
      setRefinedSectors(normalizedSectors);
      calculateTotal(normalizedSectors);
      
      // Detect and log issues
      const issues = detectSectorIssues(normalizedSectors);
      if (issues.length > 0) {
        console.warn('[SectorRefinement] Detected issues:', issues);
      }
    }
  }, [isOpen, originalSectors]);

  const calculateTotal = (sectors: any[]) => {
    // Only calculate total for DAC sectors (valid 5-digit codes)
    const dacSectors = sectors.filter(sector => sector.isValid && /^\d{5}$/.test(sector.code));
    const total = dacSectors.reduce((sum, sector) => sum + (sector.percentage || 0), 0);
    console.log('[Calculate Total] DAC sectors:', dacSectors.length, 'Total:', total);
    setTotalPercentage(total);
  };

  const handleSectorChange = (index: number, field: string, value: any) => {
    const updated = [...refinedSectors];
    if (field === 'code') {
      // When code changes, update the name too
      const selectedSubsector = updated[index].availableSubsectors.find((s: any) => s.code === value);
      updated[index].code = value;
      updated[index].name = selectedSubsector?.name || value;
      updated[index].isValid = isValidSectorCode(value);
    } else {
      updated[index][field] = value;
    }
    
    setRefinedSectors(updated);
    if (field === 'percentage') {
      calculateTotal(updated);
    }
  };

  const handleAddSubsector = (originalCode: string, originalPercentage: number) => {
    const availableSubsectors = getSubsectorsFor3DigitCode(originalCode);
    
    // Find an unused subsector (one that's not already selected for this original code)
    const existingSectorCodes = refinedSectors
      .filter(s => s.originalCode === originalCode)
      .map(s => s.code);
    
    const unusedSubsector = availableSubsectors.find(sub => !existingSectorCodes.includes(sub.code));
    
    if (unusedSubsector) {
      const newSector = {
        originalCode: originalCode,
        originalPercentage: originalPercentage,
        code: unusedSubsector.code,
        name: unusedSubsector.name,
        percentage: 0, // User will need to set this
        availableSubsectors: availableSubsectors,
        needsRefinement: true,
        isValid: isValidSectorCode(unusedSubsector.code),
        id: crypto.randomUUID() // Add unique ID for React keys
      };
      
      setRefinedSectors([...refinedSectors, newSector]);
    }
  };

  const handleRemoveSubsector = (index: number) => {
    const updated = refinedSectors.filter((_, i) => i !== index);
    setRefinedSectors(updated);
    calculateTotal(updated);
  };

  const handleDistributeEqually = (originalCode: string) => {
    const sectorsForOriginal = refinedSectors.filter(s => s.originalCode === originalCode && s.isValid);
    const originalSector = refinedSectors.find(s => s.originalCode === originalCode);
    
    if (sectorsForOriginal.length > 0 && originalSector) {
      const equalPercentage = Math.round((originalSector.originalPercentage / sectorsForOriginal.length) * 100) / 100;
      
      const updated = refinedSectors.map(s => {
        if (s.originalCode === originalCode && s.isValid) {
          return { ...s, percentage: equalPercentage };
        }
        return s;
      });
      
      setRefinedSectors(updated);
      calculateTotal(updated);
    }
  };

  const handleNormalizePercentages = () => {
    // Only normalize DAC sectors
    const dacSectors = refinedSectors.filter(sector => sector.isValid && /^\d{5}$/.test(sector.code));
    const nonDacSectors = refinedSectors.filter(sector => !sector.isValid || !/^\d{5}$/.test(sector.code));
    
    const normalizedDacSectors = normalizePercentages(dacSectors);
    const normalized = [...normalizedDacSectors, ...nonDacSectors];
    
    setRefinedSectors(normalized);
    calculateTotal(normalized);
  };

  const handleEqualDistribution = () => {
    // Only distribute equally among DAC sectors
    const dacSectors = refinedSectors.filter(sector => sector.isValid && /^\d{5}$/.test(sector.code));
    console.log('[Distribute Equally] DAC sectors found:', dacSectors.length, dacSectors);
    
    if (dacSectors.length === 0) return;
    
    // Calculate base percentage and remainder to ensure exact 100% total
    const basePercentage = Math.floor((100 / dacSectors.length) * 100) / 100; // Round down to 2 decimal places
    const remainder = 100 - (basePercentage * dacSectors.length);
    
    console.log('[Distribute Equally] Base percentage:', basePercentage, 'Remainder:', remainder);
    
    let dacSectorIndex = 0;
    const updated = refinedSectors.map(s => {
      // Only update percentage for DAC sectors
      if (s.isValid && /^\d{5}$/.test(s.code)) {
        // Add remainder to only the first sector to ensure exact 100%
        const extraAmount = dacSectorIndex === 0 ? remainder : 0;
        const finalPercentage = Math.round((basePercentage + extraAmount) * 100) / 100; // Round to 2 decimal places
        dacSectorIndex++;
        
        console.log('[Distribute Equally] Sector', s.code, 'gets percentage:', finalPercentage);
        return { ...s, percentage: finalPercentage };
      }
      return s; // Keep non-DAC sectors unchanged
    });
    
    console.log('[Distribute Equally] Updated sectors:', updated);
    setRefinedSectors(updated);
    
    // Use setTimeout to ensure state update happens before calculation
    setTimeout(() => {
      calculateTotal(updated);
    }, 0);
  };

  const handleSave = () => {
    if (Math.abs(totalPercentage - 100) > 0.01) {
      toast.error('Sector percentages must total 100%');
      return;
    }
    onSave(refinedSectors);
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Settings className="h-5 w-5" />
            Refine Sector Classifications
          </DialogTitle>
          <DialogDescription>
            This activity has 3-digit sector categories from imported data. Please select specific 5-digit sub-sectors 
            and reallocate percentages. The total must equal 100%.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          {/* Progress indicator and controls */}
          <div className="bg-gray-50 p-3 rounded-lg space-y-3">
            <div className="flex justify-between items-center">
              <span className="text-sm font-medium text-gray-700">
                Total Percentage (DAC Sectors Only): 
              </span>
              <div className="flex items-center gap-3">
                <span className={`font-bold ${
                  Math.abs(totalPercentage - 100) < 0.01 
                    ? 'text-gray-800' 
                    : 'text-gray-600'
                }`}>
                  {totalPercentage.toFixed(1)}%
                </span>
                <div className="flex gap-1">
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={handleEqualDistribution}
                    className="text-xs px-2 py-1 bg-gray-100 text-gray-700 border-gray-300 hover:bg-gray-200"
                  >
                    Distribute Equally
                  </Button>
                </div>
              </div>
            </div>
            
            <div className="w-full bg-gray-100 rounded-full h-1">
              <div 
                className={`h-1 rounded-full transition-all ${
                  Math.abs(totalPercentage - 100) < 0.01 
                    ? 'bg-gray-300' 
                    : 'bg-gray-400'
                }`}
                style={{ width: `${Math.min(totalPercentage, 100)}%` }}
              />
            </div>
            
          </div>

          {/* Refinement table */}
          <div className="border rounded-lg overflow-hidden">
            <table className="w-full">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">
                    Original (3-digit)
                  </th>
                  <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase">
                    Refined (5-digit)
                  </th>
                  <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase w-24">
                    %
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200">
                {/* Group sectors by original code */}
                {Object.entries(
                  dacSectors.reduce((groups: Record<string, any[]>, sector: any) => {
                    const originalCode = sector.originalCode;
                    if (!groups[originalCode]) groups[originalCode] = [];
                    groups[originalCode].push(sector);
                    return groups;
                  }, {} as Record<string, any[]>)
                ).map(([originalCode, sectorsGroup]: [string, any[]]) => (
                  <React.Fragment key={originalCode}>
                    {sectorsGroup.map((sector: any, groupIndex: number) => {
                      const originalIndex = refinedSectors.findIndex(s => s === sector);
                      const isFirstInGroup = groupIndex === 0;
                      const availableSubsectors = getSubsectorsFor3DigitCode(originalCode);
                      const usedCodes = sectorsGroup.map((s: any) => s.code);
                      const hasUnusedSubsectors = availableSubsectors.some(sub => !usedCodes.includes(sub.code));
                      
                      return (
                        <tr key={sector.id || originalIndex} className="bg-white">
                          {/* Original Code Column - only show for first row of each group */}
                          <td className="px-3 py-3">
                            {isFirstInGroup && (
                              <div className="text-sm">
                                <div className="font-mono text-xs text-gray-600">
                                  {sector.originalCode}
                                </div>
                                <div className="text-gray-500 text-xs">
                                  {sector.originalPercentage}% original
                                </div>
                              </div>
                            )}
                          </td>
                          
                          {/* Refined Sector Column */}
                          <td className="px-3 py-3">
                            <div className="space-y-2">
                              <div className="flex items-center gap-2">
                                <div className="flex-1">
                                  {sector.availableSubsectors.length > 0 ? (
                                    <PortalDropdown
                                      sector={sector}
                                      sectorsGroup={sectorsGroup}
                                      originalIndex={originalIndex}
                                      isOpen={openPopoverId === sector.id}
                                      onToggle={() => setOpenPopoverId(openPopoverId === sector.id ? null : sector.id)}
                                      onSelect={(code) => {
                                        handleSectorChange(originalIndex, 'code', code);
                                        setOpenPopoverId(null);
                                      }}
                                    />
                                  ) : (
                                    <div className="text-sm text-gray-500 italic">
                                      No subsectors available
                                    </div>
                                  )}
                                </div>
                                
                                {/* Remove button - only show if there are multiple subsectors for this original code */}
                                {sectorsGroup.length > 1 && (
                                  <Button
                                    type="button"
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => handleRemoveSubsector(originalIndex)}
                                    className="h-8 w-8 p-0 text-gray-400 hover:text-red-600"
                                  >
                                    <Trash2 className="h-4 w-4" />
                                  </Button>
                                )}
                              </div>
                              
                              {/* Add Subsector button - show for the last row of each group and if there are unused subsectors */}
                              {groupIndex === sectorsGroup.length - 1 && hasUnusedSubsectors && (
                                <div className="flex justify-start">
                                  <Button
                                    type="button"
                                    variant="default"
                                    size="sm"
                                    onClick={() => handleAddSubsector(originalCode, sector.originalPercentage)}
                                    className="h-8 px-3 text-xs bg-blue-600 hover:bg-blue-700 text-white"
                                  >
                                    <Plus className="h-3 w-3 mr-1" />
                                    Add Subsector
                                  </Button>
                                </div>
                              )}
                            </div>
                          </td>
                          
                          {/* Percentage Column */}
                          <td className="px-3 py-3">
                            <div className="space-y-2">
                              <div className="flex items-center h-10">
                                <Input
                                  type="number"
                                  min="0"
                                  max="100"
                                  step="0.1"
                                  value={sector.percentage || ''}
                                  onChange={(e) => handleSectorChange(originalIndex, 'percentage', parseFloat(e.target.value) || 0)}
                                  className="w-20 text-sm"
                                  placeholder="0"
                                />
                              </div>
                              {/* Empty space to match the Add Subsector button space */}
                              {groupIndex === sectorsGroup.length - 1 && hasUnusedSubsectors && (
                                <div className="h-8"></div>
                              )}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                  </React.Fragment>
                ))}
                
                {/* Non-DAC Sectors (Locked) */}
                {nonDacSectors.length > 0 && (
                  <>
                    <tr className="bg-gray-100">
                      <td colSpan={3} className="px-3 py-2">
                        <div className="flex items-center gap-2 text-xs font-medium text-gray-600 uppercase tracking-wide">
                          <Lock className="h-3 w-3" />
                          Non-DAC Sectors
                        </div>
                      </td>
                    </tr>
                    {nonDacSectors.map((sector, index) => {
                      const originalIndex = refinedSectors.findIndex(s => s === sector);
                      return (
                        <tr key={originalIndex} className="bg-gray-50">
                          <td className="px-3 py-3">
                            <div className="text-sm">
                              <div className="font-mono text-xs text-gray-500">
                                {sector.originalCode}
                              </div>
                              <div className="text-gray-400 text-xs">
                                {sector.originalPercentage}% original
                              </div>
                            </div>
                          </td>
                          <td className="px-3 py-3">
                            <div className="text-sm">
                              <div className="flex items-center gap-2 mb-1">
                                <span className="text-xs font-mono text-gray-400 bg-gray-200 px-1.5 py-0.5 rounded">{sector.code}</span>
                                <span className="font-medium text-gray-500">{sector.name}</span>
                              </div>
                            </div>
                          </td>
                          <td className="px-3 py-3">
                            <Input
                              type="number"
                              min="0"
                              max="100"
                              step="0.1"
                              value={sector.percentage}
                              disabled
                              className="w-full text-xs bg-gray-100 text-gray-500"
                            />
                          </td>
                        </tr>
                      );
                    })}
                  </>
                )}
              </tbody>
            </table>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose} className="bg-gray-100 text-gray-700 border-gray-300 hover:bg-gray-200">
            Cancel
          </Button>
          <Button 
            onClick={handleSave}
            disabled={Math.abs(totalPercentage - 100) > 0.01}
            className="bg-blue-600 text-white hover:bg-blue-700 disabled:bg-gray-400"
          >
            Save Refined Sectors
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};